# Шпаргалка по JS

###Debug
Отсчет времени по метке:

    console.time('1') //начнет отсчет времени
    console.timeEnd('1') //закончит отсчет времени и выведет в консоль

###Типы данных
####Арифметические операторы
Унарный **+** приводит к _Number_.

    var arg = /*что угодно*/;
    +arg; //Number
    +Null; //0
    +''; //0
    +'123'; //123
    +'abc'; //NaN
    +undefined //NaN

Бинарный **+** приводит к _Number_.
Если один из аргументов - _String_, то приводит все к _String_
и делает конкатенацию.

Бинарные **- * /** приводят к _Number_.

Унарные **++** и **--** приводят к числу.

####Сравнение
_==_ - сравнение с приведением типов.
_===_ - строгое сравнение.

Если один из операндов - _Number_ или _Boolean_, то все приводится к числу,
если _String_ - то все приводится к строке. _null_ и _undefined_
равны только друг другу (и самим себе). NaN не равен вообще ничему.

    +0 === -0; //true
    NaN == NaN; //false
    null == undefined; //true
    ['x'] == 'x'; //true
    true == 1; //true

Строки сравниваются по кодам символов. Чтобы сравнивать в алфавитном порядке,
юзаем _str.localeCompare_

    'ёжик' < 'ящик'; //false
    'ёжик'.localeCompare('ящик'); //-1, т.е. меньше

####Побитовые операторы
_~, &, |, ^, >>, >>>, <<_.

Все они работают с 32-разрядными signed int.
_>>>_ - побитовый сдвиг вправо (дополняя слева нулями).
_^_ используется для округления числа до целого:

    12.345 ^ 0; // 12

С помощью _~_ делается проверка на -1:

    (~num) //true if num != -1

####Логические операторы
_&&, ||, !_

_&&_ возвращает первый ложный операнд (или последний если все истинны).
_||_ возвращает первый истинный операнд (или последний если все ложны).
С помощью _!_ можно привести значение к _Boolean_:

    !!123; //true

**Приведение к _Boolean_**:
_0, '', null, undefined, NaN_ => false;
_[], {}_ и все остальное => true

Выражение в _if, while, for_ приводится к _Boolean_

####switch case
В _case_ сравнивает строго, т.е. через _===_

####typeof

    typeof(arg); //или
    typeof arg;
    typeof(null); //object - это ошибка в языке
	typeof []; //object
	typeof {}; //object


####Boolean
Не надо создавать _Boolean_ как объект!

    var b1 = true;
    if(b1)
        ok(); //тут все нормально
    var b2 = new Boolean(false)
    if(b2)
        ok(); //тут сработает, хотя мы инициализировали false. Потому что это объект.


####Number
Особые значения: _**NaN**_ и _**Infinity**_.

    Что_угодно <арифм. оператор> NaN; //NaN
Проверка на _NaN_ и _Infinity_:

    isNaN(arg); //arg приводится к числу
    isFinite(arg); //вернет true если arg != NaN или +-Infinity
_**String**_ to _**Number**_:

Будут парсить строку с первого символа, первый "неправильный" символ
и все что за ним отбрасываются.
Нестроковые аргументы приводятся к строке.

    parseInt(''); //NaN
    parseInt('px12'); //NaN
    parseInt('12px'); //12
    parseFloat('12.3.4.54'); //12.3

**Округление**:

    arg.toFixed(n); //округлить arg до n знаков после запятой, n >= 0
    //можно и с числовыми литералами (но не забываем что у них есть своя точка)
    12.toFixed(2); //ошибка!
    12.0.toFixed(2); //12.00

Очень аккуратно работаем с флоатами:

    .1 + .2; //0.30000000000000004

_Хитрый пример:_

    alert( 9999999999999999 ); // выведет 10000000000000000

####String
Символ на _n_-й позиции:

    strVar.charAt(n);
    strVar[n];

    "".charAt(0); //пустая строка
    ""[0]; //undefined

Многострочная строка: каждая линия оканчивается на \

    var ssstring = "lalala \
                    bebebe";

Подстрока:

    substring(start, end);
Если _start_ > _end_ то они меняются местами.
Если _start_ < 0 то _start_ = 0, аналогично с _end_.

    substr(start [, length]);
_start_ - как в _substring_. Вместо _end_ - _length_.

    slice(start [, end]);
Как _substring_, но отрицательные агрументы будут
 считаться с конца (как в питоне)

###Функции
**Function declaration**

    function foo() { return 5; }
Такая функция будет объявлена до выполнения кода.

**Anonymous function expression**

    var foo = function() { return 5; }
А такая - только когда до неё дойдет (на самом деле до выполнения кода
будет объявлена _var foo = undefined_).

**Named function expression**

    var foo = function bar() { return 5; }
Из внешнего кода мы не сможем вызвать _bar()_, зато использовать изнутри
для рекурсивных вызовов.

**Как не надо объявлять**

    var sum = new Function('a,b', ' return a+b; ');
Первый параметр - аргументы, второй - тело.

Если функция ничего не возвращает, то вернется _undefined_.

_arguments_ лучше не изменять, потому что изменятся ли
именованные параметры от этого - хз, зависит от интерпретатора.
'use strict' решает проблему - при изменении _arguments_ именованные параметры не меняются

Как в питоне _f(arg1 = 1, arg3 = 4)_ нельзя, это обходится с помощью
_f(options)_, где _options = {arg1: 1, arg3: 4}_.

//TODO: https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/
