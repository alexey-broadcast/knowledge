# Шпаргалка по JS

###Debug
Отсчет времени по метке:

    console.time('1') //начнет отсчет времени
    console.timeEnd('1') //закончит отсчет времени и выведет в консоль

###Типы данных
####Приведение типов
Унарный **+** приводит к _Number_.

    var arg = /*что угодно*/;
    +arg; //Number
    +Null; //0
    +''; //0
    +'123'; //123
    +'abc'; //NaN
    +undefined //NaN

Бинарный **+** приводит к _Number_.
Если один из аргументов - _String_, то приводит все к _String_
и делает конкатенацию.

Бинарные **- * /** приводят к _Number_.

Унарные **++** и **--** приводят к числу.

####Boolean
Не надо создавать _Boolean_ как объект!

    var b1 = true;
    if(b1)
        ok(); //тут все нормально
    var b2 = new Boolean(false)
    if(b2)
        ok(); //тут сработает, хотя мы инициализировали false. Потому что это объект.


####Number
Особые значения: _**NaN**_ и _**Infinity**_.

    Что_угодно <арифм. оператор> NaN; //NaN
Проверка на _NaN_ и _Infinity_:

    isNaN(arg); //arg приводится к числу
    isFinite(arg); //вернет true если arg != NaN или +-Infinity
_**String**_ to _**Number**_:

Будут парсить строку с первого символа, первый "неправильный" символ
и все что за ним отбрасываются.
Нестроковые аргументы приводятся к строке.

    parseInt('px12') //NaN
    parseInt('12px') //12
    parseFloat('12.3.4.54') //12.3

**Округление**:

    arg.toFixed(n); //округлить arg до n знаков после запятой, n >= 0
    //можно и с числовыми литералами (но не забываем что у них есть своя точка)
    12.toFixed(2); //ошибка!
    12.0.toFixed(2); //12.00

Очень аккуратно работаем с флоатами:

    .1 + .2; //0.30000000000000004

_Хитрый пример:_

    alert( 9999999999999999 ); // выведет 10000000000000000

####String
Символ на _n_-й позиции:

    strVar.charAt(n);
    strVar[n];

    "".charAt(0); //пустая строка
    ""[0]; //undefined

Многострочная строка: каждая линия оканчивается на \

    var ssstring = "lalala \
                    bebebe";

Подстрока:

    substring(start, end);
Если _start_ > _end_ то они меняются местами.
Если _start_ < 0 то _start_ = 0, аналогично с _end_.

    substr(start [, length]);
_start_ - как в _substring_. Вместо _end_ - _length_.

    slice(start [, end]);
Как _substring_, но отрицательные агрументы будут
 считаться с конца (как в питоне)
