# Шпаргалка по JS

###Debug
Отсчет времени по метке:

    console.time('1') //начнет отсчет времени
    console.timeEnd('1') //закончит отсчет времени и выведет в консоль

###Типы данных
####Арифметические операторы
Унарный **+** приводит к _Number_.

    var arg = /*что угодно*/;
    +arg; //Number
    +Null; //0
    +''; //0
    +'123'; //123
    +'+38'; //38
    +'abc'; //NaN
    +undefined //NaN

Бинарный **+** приводит к _Number_.  
Если один из аргументов - _String_, то приводит все к _String_
и делает конкатенацию.

Бинарные **- * /** приводят к _Number_.

Унарные **++** и **--** приводят к числу.

####Сравнение
_==_ - сравнение с приведением типов.
_===_ - строгое сравнение.

Если один из операндов - _Number_ или _Boolean_, то все приводится к числу,
если _String_ - то все приводится к строке. _null_ и _undefined_
равны только друг другу (и самим себе). NaN не равен вообще ничему.

    +0 === -0; //true
    NaN == NaN; //false
    null == undefined; //true
    ['x'] == 'x'; //true
    true == 1; //true

Строки сравниваются по кодам символов. Чтобы сравнивать в алфавитном порядке,
юзаем _str.localeCompare_

    'ёжик' < 'ящик'; //false
    'ёжик'.localeCompare('ящик'); //-1, т.е. меньше

####Побитовые операторы
_~, &, |, ^, >>, >>>, <<_.

Все они работают с 32-разрядными signed int.
_>>>_ - побитовый сдвиг вправо (дополняя слева нулями).
_^_ используется для округления числа до целого:

    12.345 ^ 0; // 12

С помощью _~_ делается проверка на -1:

    (~num) //true if num != -1

####Логические операторы
_&&, ||, !_

_&&_ возвращает первый ложный операнд (или последний если все истинны).
_||_ возвращает первый истинный операнд (или последний если все ложны).
С помощью _!_ можно привести значение к _Boolean_:

    !!123; //true

**Приведение к _Boolean_**:
_0, '', null, undefined, NaN_ => false;
_[], {}_ и все остальное => true

Выражение в _if, while, for_ приводится к _Boolean_

####switch case
В _case_ сравнивает строго, т.е. через _===_

####typeof

    typeof(arg); //или
    typeof arg;
    typeof(null); //object - это ошибка в языке
	typeof []; //object
	typeof {}; //object


####eval
Без _"use strict"_ запускает код в текущей области видимости
с ней - создается своя (внешние функции и переменные читать/писать можно,
внутри объявленные внутри и останутся).

####Boolean
Не надо создавать _Boolean_ как объект!

    var b1 = true;
    if(b1)
        ok(); //тут все нормально
    var b2 = new Boolean(false)
    if(b2)
        ok(); //тут сработает, хотя мы инициализировали false. Потому что это объект.


####Number
Особые значения: _**NaN**_ и _**Infinity**_.

    Что_угодно <арифм. оператор> NaN; //NaN
Проверка на _NaN_ и _Infinity_:

    isNaN(arg); //arg приводится к числу
    isFinite(arg); //вернет true если arg != NaN или +-Infinity
_**String**_ to _**Number**_:

Будут парсить строку с первого символа, первый "неправильный" символ
и все что за ним отбрасываются.
Нестроковые аргументы приводятся к строке.

    parseInt(''); //NaN
    parseInt('px12'); //NaN
    parseInt('12px'); //12
    parseFloat('12.3.4.54'); //12.3

**Округление**:

    arg.toFixed(n); //округлить arg до n знаков после запятой, n >= 0
    //можно и с числовыми литералами (но не забываем что у них есть своя точка)
    12.toFixed(2); //ошибка!
    12.0.toFixed(2); //12.00

Очень аккуратно работаем с флоатами:

    .1 + .2; //0.30000000000000004

_Хитрый пример:_

    alert( 9999999999999999 ); // выведет 10000000000000000

####String
Символ на _n_-й позиции:

    strVar.charAt(n);
    strVar[n];

    "".charAt(0); //пустая строка
    ""[0]; //undefined

Многострочная строка: каждая линия оканчивается на \

    var ssstring = "lalala \
                    bebebe";

Подстрока:

    substring(start, end);
Если _start_ > _end_ то они меняются местами.  
Если _start_ < 0 то _start_ = 0, аналогично с _end_.

    substr(start [, length]);
_start_ - как в _substring_. Вместо _end_ - _length_.

    slice(start [, end]);
Как _substring_, но отрицательные агрументы будут
 считаться с конца (как в питоне)

###Функции
**Function declaration**

    function foo() { return 5; }
Такая функция будет объявлена до выполнения кода.

**Anonymous function expression**

    var foo = function() { return 5; }
А такая - только когда до неё дойдет (на самом деле до выполнения кода
будет объявлена _var foo = undefined_).

**Named function expression**

    var foo = function bar() { return 5; }
Из внешнего кода мы не сможем вызвать _bar()_, зато использовать изнутри
для рекурсивных вызовов.

**Как не надо объявлять**

    var sum = new Function('a,b', ' return a+b; ');
Первый параметр - аргументы, второй - тело.

Если функция ничего не возвращает, то вернется _undefined_.

_arguments_ лучше не изменять, потому что изменятся ли
именованные параметры от этого - хз, зависит от интерпретатора.
'use strict' решает проблему - при изменении _arguments_ именованные параметры не меняются

Как в питоне _f(arg1 = 1, arg3 = 4)_ нельзя, это обходится с помощью
_f(options)_, где _options = {arg1: 1, arg3: 4}_.

//TODO: https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/


#####Декораторы:
https://learn.javascript.ru/decorators

    function decorate(f) {
        //some code...
        return function() {
            return f.apply(this, arguments);
        }
    }
    function Func() {};
    Func = decorate(Func);
**Примеры использования:** Проверка типов входных данных, проверка прав и т.д.

#####bind:
Позволяет привязать контекст (this) к функции:
`var wrapper = func.bind(context[, arg1, arg2...])` - arg1, arg2...
будут добавлены _перед_ явно переданными аргументами

    function f() {
        console.log(this);
    }
    var g = f.bind("Context");
    f() //выведется 'Context'

Если мы просто создаем функцию, в которой какие-то из аргументов будут
дефолтными - то это называется _карринг_ (или _каррирование_).

    function mul(a,b) {return a*b;}; //перемножает два аргумента
    var double = mul.bind(null, 2); //контекст = null, первый аргумент = 2
    double(3); //вернет 6

##### apply:
_Форвардинг вызова_ - вызываем функцию через к-л декоратор
чтобы изнутри все выглядело будто нет никакого декоратора.

    var result = f.apply(this, arguments);

###Массивы

    var arr1 = [10]; //Массив из одного элемента равного 10
    var arr2 = new Array(10); //Массив из 10 элементов равных undefined
`pop()` - возвращает длину до попа.  
`shift()` - js-ный pop_front  
`push()` - возвращает полученную длину, иожет принимать несколько аргументов  
`unshift()` - js-ный push_front, возвращает полученную длину, м ожет принимать несколько аргументов  

Для обхода массива не надо использовать _for in_! А то выведутся все свойства
не только по цифровым индексам
`arr.length` - номер наибольшего индекса + 1. Может быть слева
от оператора присваивания (только вот нахуя?).

`string.split(symbol, num)`:

    "a,b,c,d".split(',', 2); // 'a', 'b'
    "abcd".split(''); // 'a', 'b', 'c', 'd'

`join(sym)`:

    [1, 2, 3].join('+'); // '1+2+3'
    new Array(4).join("ля"); // ляляляля

`splice( start, deleteCount, [elem1[, elem2[, ...[, elemN]]]] )`:
начиная с позиции _start_ удалить _deleteCount_ элементов, и туда же
вставить элементы _elem1, elem2..._ _start_ может быть и отрицательным -
тогда отсчет начнется с конца. Вовращает массив из удаленных элементов.

`slice(begin, end)`: возвращает участок массива от begin до end, не включая end.
Исходный массив при этом не меняется. Отрицательные аргументы можно.

`sort(function(a, b) {})`: если функция не указана, то все элементы приводит
к строке и сравнивает в лексикографическом порядке.

	sort(function(a, b) {
		//Она должна возвращать:
		//Положительное значение, если a > b,
		//Отрицательное значение, если a < b,
		//Если равны — можно 0, но вообще — не важно
	})

`reverse()`

`concat(param1, param2 ...)`: _param_ может быть массивом,
тогда добавится не массив, а элементы из массива

    var arr = [1, 2];
    var newArr = arr.concat([3, 4], 5); //[1, 2, 3, 4, 5]

`indexOf(searchElement[, fromIndex])` - используется строгое сравнение ===
`lastIndexOf(searchElement[, fromIndex])` - используется строгое сравнение ===

###Объекты
Всегда и везде передаются по ссылке!  
~~В консоли браузера объект выводится по текущему состоянию (даже если был выведен
100500 лет назад)~~

Это будут два разных объекта. Например в первом есть метод toString():

    var obj = {};
    var obj = Object.create(null);


    if('member' in person) func();//проверка на существование поля
    delete obj.member;
    obj.member; //undefined
Обход полей объекта: при таком обходе сначала идут отсортированные числа, потом -
строки в порядке объявления. Если мы не хотим сортировать строки вида '12'
(числа) - то пишем их как '+12' - тогда они и сортироваться не будут, и прекрасно приводятся к число

    for(key in obj)

**Приведение к строке и числу** реализуется переопределением методов
`valueOf()` и `toString()`. Они необязательно должны возвращать именно
_Number_ и _String_, любой примитив. Он потом будет приведен дополнительно

**Геттеры и сеттеры**

    var user = {
      firstName: "Вася",
      surname: "Петров",
      get fullName() {
        return this.firstName + ' ' + this.surname;
      },
      set fullName(value) {
        var split = value.split(' ');
        this.firstName = split[0];
        this.surname = split[1];
      }
    };
    user.fullName //вернет "Вася Петров"
    user.fullName = "Petya Ivanov" //все сработает

**Свойства объекта** (работает аналогично Q_PROPERTY)

    Object.defineProperty(obj, prop, descriptor)
Дескриптор — объект, который описывает поведение свойства.
В нём могут быть следующие поля:  
`value` — значение свойства, по умолчанию undefined.  
`writable` — значение свойства можно менять, если true. По умолчанию false.  
`configurable` — если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.  
`enumerable` — если true, то свойство будет участвовать в переборе for..in. По умолчанию false.  
`get` — функция, которая возвращает значение свойства. По умолчанию undefined. //справа от присваивания. Вызывается как переменная-член без скобок  
`set` — функция, которая записывает значение свойства. По умолчанию undefined. //слева от присваивания. Вызывается как переменная-член без скобок  
Запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух.  
Также запрещено и не имеет смысла указывать writable при наличии get/set-функций  

**Статические члены**
Имеем класс Animal.

    Animal.count = 0; //вот статическое свойство класса
    Animal.setCount = function(n) {
        this.count = n;
    } //доступ из статических методов к статическим полям через this.

**Методы объекта**

    Object.defineProperties(obj, descriptors); //descriptors - это {} пар prop-descriptor
	Object.keys(obj);
	Object.getOwnPropertyNames(obj); //вернет вообще все, даже не-enumerable
	Object.getOwnPropertyDescriptor(obj, prop);
	Object.preventExtensions(obj); //после этого новые свойства больше не добавить
    Object.isExtensible(obj);
	Object.seal(obj); //после этого свойства больше не добавить, не удалить, все становятся не-configurable
    Object.isSealed(obj);
	Object.freeze(obj); //как прошлый + запрет изменения, все свойства становятся не-writable
	Object.isFrozen(obj);

**_this_ в методах объекта**  
Вызов `obj.method()` (объект-точка-метод-скобки)  
или `obj[method]()` (объект-метод в квадратных скобках-скобки)  
порождает значение специального типа _Reference Type_ (base-name-strict):  
  * _base_ — как раз объект,  
  * _name_ — имя свойства,  
  * _strict_ — вспомогательный флаг для передачи use strict.
Без скобок (`obj.method`) просто получаем name и используем, без привязки к base

    user.hi(); // this - это user
    (user.name == "Вася" ? user.hi : user.bye)(); // this - это хз что

**bind**:  
`method.bind(object)`
Вот так мы сохраним user как this, и его состояние на момент setTimeout
    setTimeout(user.sayHi.bind(user), 1000);

**call**:  
`func.call(object, arg1, arg2)` = func(arg1, arg2) с явно указанным this = object

    var join = [].join; // скопируем ссылку на функцию в переменную
    var argStr = join.call(arguments, ':'); //и вызовем ее для arguments
**apply**:
`func.apply(object, [arg1, arg2])` это все равно что `func.call(object, arg1, arg2)`.  
Только передаются не отдельные аргументы, а массив аргументов.

####Date, Time
`new Date()` - вернет текущее время.
`Date(msecs)` - c 01.01.1970 GMT+0
`Date(datestring)`
`Date(year, month, date=1, hours=0, minutes=0, seconds=0, ms=0)`
_year_ - 4 цифры, _month_ = от 0 до 11
`getFullYear()`, `getMonth()`, `getDate()`, `getHours()`, `getMinutes()`, `getSeconds()`, `getMilliseconds()`, `getDay()` - номер дня в неделе от 0 до 6.  
Есть аналогичные сеттеры, есть аналогичные методы для UTC  
`toLocaleString(локаль, опции)`
`toString()`, `toDateString()`, `toTimeString()`
`parse(str)`
`now()`: он аналогичен вызову _+new Date()_, но в отличие от него
не создаёт промежуточный объект даты, а поэтому — во много раз быстрее
при бинарном **+** используется _toString_, а не _valueOf_
