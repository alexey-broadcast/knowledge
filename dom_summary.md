`console.log` и `console.dir` - разные выводы (пробовать на HTML-объектах)

`window` содержит свойства и методы для управления окном браузера, открытия
новых окон...

`document` даёт возможность взаимодействовать с содержимым страницы.

**BOM** — это объекты для работы с чем угодно, кроме документа:
 - `navigator`
 - `screen`
 - `location`
 - `frames`
 - `history`
 - `XMLHttpRequest`

`navigator` содержит общую информацию о браузере и операционной системе.
Особенно примечательны два свойства:  
`navigator.userAgent` — содержит информацию о браузере  
`navigator.platform` — содержит информацию о платформе,
позволяет различать Windows/Linux/Mac  
`alert`/`confirm`/`prompt` — тоже входят в BOM


# DOM
Всего различают 12 типов узлов, но на практике мы работаем с четырьмя из них:
 1. **Документ** — точка входа в DOM.
 2. **Элементы** — основные строительные блоки.
 3. **Текстовые узлы** — содержат, собственно, текст.
 4. **Комментарии** — иногда в них можно включить информацию, которая не будет
 показана, но доступна из JS.

```JavaScript
document.documentElement; //HTML
document.head; // <head>...</head> // IE9+
document.body; // <body>...</body>
```
> _Тонкость_: если скрипт выполняется до того, как загрузился **body**, то
`document.body == null`  
И вообще, если какой-то элемент не определен, то в операциях с DOM возвращается
`null`, а не `undefined`

### Навигация по DOM
> Здесь и далее:
**дети** - потомки первого уровня  
**потомки** - все потомки

`elem.childNodes` - массив с детьми, константный метод  
Данный метод возвращает не JS-массив, а "коллекцию". Всякие filter и прочее
работать не будут. Для того чтобы это сделать есть два метода:
 1. `Array.prototype.method.call`
 2. `var arr = Array.prototype.slice.call(collection);`

> **Для обхода коллекции нельзя использовать `for in` !!!**


`elem.firstChild` - первый потомок  
`elem.lastChild` - последний потомок  
`elem.previousSibling` - следующий "брат"  
`elem.nextSibling` - предыдущий "брат"  
`elem.parentNode` - родитель  
`elem.hasChildNodes` - проверка, есть ли детки

Есть аналогичные методы, которые не включают текстовые узлы:  
`elem.children`  
`elem.firstElementChild`  
`elem.lastElementChild`  
`elem.previousElementSibling`  
`elem.nextElementSibling`  
`elem.parentElement`  

Отличие `elem.parentNode` от `elem.parentElement`:
```JavaScript
document.documentElement.parentNode; // document
document.documentElement.parentElement; // null
```
> В IE8- из всего этого есть только `children`, причем в возвращенной коллекции
будут и узлы-комментарии

#### Особые ссылки таблиц
`table.rows` — коллекция строк TR таблицы.  
`table.caption/tHead/tFoot` — ссылки на элементы таблицы CAPTION, THEAD, TFOOT.  
`table.tBodies` — коллекция элементов таблицы TBODY,
по спецификации их может быть несколько.  
`tbody.rows` — коллекция строк TR секции  
`tr.cells` — коллекция ячеек TD/TH  
`tr.sectionRowIndex` — номер строки в текущей секции THEAD/TBODY  
`tr.rowIndex` — номер строки в таблице  
`td/th.cellIndex` — номер ячейки в строке  

### Поиск элемента
#### По id
Как делать не надо:
```HTML
<div id="content-holder">
  <div id="content">Элемент</div>
</div>

<script>
  alert( content ); // DOM-элемент
  alert( window['content-holder'] ); // в имени дефис, поэтому через [...]
</script>
```
Такое поведение существует лишь для обратной совместимости. Для выдергивания
элемента по id используем  
`document.getElementById("идентификатор")`  
Таким образом можем искать только внутри `document`
> Если вдруг в документе несколько узлов с заданным id, то поведение не
определено (какой попадется: первый, последний - хуй знает)

#### По тегу
`elem.getElementsByTagName(tag)` - возвращает список потомков с нужным тегом  
Этим методом мы можем получить всех потомков, передав `*` вместо tag

#### По name
Используется редко, но такой метод есть:  
`document.getElementsByName('age')` - возвращает список элементов
с атрибутом name равным 'age'

### По классу
`document.getElementsByClassName('article')` - вернет список элементов
с заданным классом (если у элемента несколько классов и хоть один из
них подходит - то элемент подходит)

### По селектору
`elem.querySelectorAll(selector)` - вернет список элементов,
удовлетворяющих css-селектору
`elem.querySelector(selector)` - все равно что
`elem.querySelectorAll(selector)[0]`,
но сработает быстрее  
`elem.matches(selector)` - проверяет, удовлетворяет ли данный элемент
селектору  
Ранее в спецификации он назывался `matchesSelector`, и большинство браузеров
поддерживают его под этим старым именем, либо с префиксами ms/moz/webkit
`elem.closest(css)` - ищет ближайший подходящий под селектор родитель
(включая сам элемент)  
Также есть поиск элементов через `XPath`, но это пиздец как сложно
и вообще нужно для XML  
`get\*` работает очень быстро, т.к. браузер хранит внутренне соответствие
id -> элемент.  
#### Как работает поиск
https://learn.javascript.ru/searching-elements-internals  
`querySelector` тупо перебирает потомков узла. Внутри браузеров имеются
оптимизации (например, `querySelector('#id')` превращается в
`getElementById`, результаты поиска кешируются до изменения документа...)  
Результат поиска `getElementsBy*` изменяется в соответствии с изменением
документа. Дело в том, что `getElementsBy*` возвращают не массив,
а специальный объект типа `NodeList` или `HTMLCollection`, который представляет
собой не готовую коллекцию, а "живой поисковый запрос"

### DOM-узел
**Разные узлы являются объектами различных классов.**
Поэтому, к примеру, у узла, соответствующего тегу `<td>` — одни свойства, у
`<form>` — другие, у `<a>` — третьи.  
`elem.nodeType` вернет тип узла (их всего 12, где элемент - 1, текст - 3).
Метод работает только на чтение  
`elem.nodeName` вернет для элементов - имя тега, для не-элементов -
строку с типом узла  
`elem.tagName` вернет имя тега
`elem.innerHTML` - внутреннее содержимое элемента в виде строки (можно
читать и писать)  
> `elem.innerHTML +=` осуществляет перезапись всего innerHTML!  
Все изображения и другие ресурсы будут перезагружены!  
Скрипты не выполнятся!  
Все введенное в инпуты сбросится!  
Выделение пропадет!  

`elem.outerHTML` - вернет весь контент элемента (включая сам элемент)  
Теоретически это свойство доступно на запись, но при этом элемент не меняется,
а заменяется на новый, а переменная в которую мы записали старый HTML остается
как была.  

`elem.data` - вернет контент текстовых/комментовых узлов (rw)  
