`console.log` и `console.dir` - разные выводы (пробовать на HTML-объектах)

`window` содержит свойства и методы для управления окном браузера, открытия
новых окон...

`document` даёт возможность взаимодействовать с содержимым страницы.

**BOM** — это объекты для работы с чем угодно, кроме документа:
 - `navigator`
 - `screen`
 - `location`
 - `frames`
 - `history`
 - `XMLHttpRequest`

`navigator` содержит общую информацию о браузере и операционной системе.
Особенно примечательны два свойства:  
`navigator.userAgent` — содержит информацию о браузере  
`navigator.platform` — содержит информацию о платформе,
позволяет различать Windows/Linux/Mac  
`alert`/`confirm`/`prompt` — тоже входят в BOM


# DOM
Всего различают 12 типов узлов, но на практике мы работаем с четырьмя из них:
 1. **Документ** — точка входа в DOM.
 2. **Элементы** — основные строительные блоки.
 3. **Текстовые узлы** — содержат, собственно, текст.
 4. **Комментарии** — иногда в них можно включить информацию, которая не будет
 показана, но доступна из JS.

```JavaScript
document.documentElement; //HTML
document.head; // <head>...</head> // IE9+
document.body; // <body>...</body>
```
> _Тонкость_: если скрипт выполняется до того, как загрузился **body**, то
`document.body == null`  
И вообще, если какой-то элемент не определен, то в операциях с DOM возвращается
`null`, а не `undefined`

### Навигация по DOM
> Здесь и далее:
**дети** - потомки первого уровня  
**потомки** - все потомки

`elem.childNodes` - массив с детьми, константный метод  
Данный метод возвращает не JS-массив, а "коллекцию". Всякие filter и прочее
работать не будут. Для того чтобы это сделать есть два метода:
 1. `Array.prototype.method.call`
 2. `var arr = Array.prototype.slice.call(collection);`

> **Для обхода коллекции нельзя использовать `for in` !!!**


`elem.firstChild` - первый потомок  
`elem.lastChild` - последний потомок  
`elem.previousSibling` - следующий "брат"  
`elem.nextSibling` - предыдущий "брат"  
`elem.parentNode` - родитель  
`elem.hasChildNodes` - проверка, есть ли детки

Есть аналогичные методы, которые не включают текстовые узлы:  
`elem.children`  
`elem.firstElementChild`  
`elem.lastElementChild`  
`elem.previousElementSibling`  
`elem.nextElementSibling`  
`elem.parentElement`  

Отличие `elem.parentNode` от `elem.parentElement`:
```JavaScript
document.documentElement.parentNode; // document
document.documentElement.parentElement; // null
```
> В IE8- из всего этого есть только `children`, причем в возвращенной коллекции
будут и узлы-комментарии

#### Особые ссылки таблиц
`table.rows` — коллекция строк TR таблицы.  
`table.caption/tHead/tFoot` — ссылки на элементы таблицы CAPTION, THEAD, TFOOT.  
`table.tBodies` — коллекция элементов таблицы TBODY,
по спецификации их может быть несколько.  
`tbody.rows` — коллекция строк TR секции  
`tr.cells` — коллекция ячеек TD/TH  
`tr.sectionRowIndex` — номер строки в текущей секции THEAD/TBODY  
`tr.rowIndex` — номер строки в таблице  
`td/th.cellIndex` — номер ячейки в строке  

### Поиск элемента
#### По id
Как делать не надо:
```HTML
<div id="content-holder">
  <div id="content">Элемент</div>
</div>

<script>
  alert( content ); // DOM-элемент
  alert( window['content-holder'] ); // в имени дефис, поэтому через [...]
</script>
```
Такое поведение существует лишь для обратной совместимости. Для выдергивания
элемента по id используем  
`document.getElementById("идентификатор")`  
Таким образом можем искать только внутри `document`
> Если вдруг в документе несколько узлов с заданным id, то поведение не
определено (какой попадется: первый, последний - хуй знает)

#### По тегу
`elem.getElementsByTagName(tag)` - возвращает список потомков с нужным тегом  
Этим методом мы можем получить всех потомков, передав `*` вместо tag

#### По name
Используется редко, но такой метод есть:  
`document.getElementsByName('age')` - возвращает список элементов
с атрибутом name равным 'age'

### По классу
`document.getElementsByClassName('article')` - вернет список элементов
с заданным классом (если у элемента несколько классов и хоть один из
них подходит - то элемент подходит)

### По селектору
`elem.querySelectorAll(selector)` - вернет список элементов,
удовлетворяющих css-селектору
`elem.querySelector(selector)` - все равно что
`elem.querySelectorAll(selector)[0]`,
но сработает быстрее  
`elem.matches(selector)` - проверяет, удовлетворяет ли данный элемент
селектору  
Ранее в спецификации он назывался `matchesSelector`, и большинство браузеров
поддерживают его под этим старым именем, либо с префиксами ms/moz/webkit
`elem.closest(css)` - ищет ближайший подходящий под селектор родитель
(включая сам элемент)  
Также есть поиск элементов через `XPath`, но это пиздец как сложно
и вообще нужно для XML  
`get\*` работает очень быстро, т.к. браузер хранит внутренне соответствие
id -> элемент.  
#### Как работает поиск
https://learn.javascript.ru/searching-elements-internals  
`querySelector` тупо перебирает потомков узла. Внутри браузеров имеются
оптимизации (например, `querySelector('#id')` превращается в
`getElementById`, результаты поиска кешируются до изменения документа...)  
Результат поиска `getElementsBy*` изменяется в соответствии с изменением
документа. Дело в том, что `getElementsBy*` возвращают не массив,
а специальный объект типа `NodeList` или `HTMLCollection`, который представляет
собой не готовую коллекцию, а "живой поисковый запрос"

### DOM-узел
**Разные узлы являются объектами различных классов.**
Поэтому, к примеру, у узла, соответствующего тегу `<td>` — одни свойства, у
`<form>` — другие, у `<a>` — третьи.  
`elem.nodeType` вернет тип узла (их всего 12, где элемент - 1, текст - 3).
Метод работает только на чтение  
`elem.nodeName` вернет для элементов - имя тега, для не-элементов -
строку с типом узла  
`elem.tagName` вернет имя тега (для HTML - всегда капсом)
`elem.innerHTML` - внутреннее содержимое элемента в виде строки (можно
читать и писать)  
> `elem.innerHTML +=` осуществляет перезапись всего innerHTML!  
Все изображения и другие ресурсы будут перезагружены!  
Скрипты не выполнятся!  
Все введенное в инпуты сбросится!  
Выделение пропадет!  

`elem.outerHTML` - вернет весь контент элемента (включая сам элемент)  
Теоретически это свойство доступно на запись, но при этом элемент не меняется,
а заменяется на новый, а переменная в которую мы записали старый HTML остается
как была.  

`elem.data` - вернет контент текстовых/комментовых узлов (rw)  
`elem.nodeValue` - как прошлый, но вместо `undefined` вернет `null` (rw)  
`elem.textContent` - вернет сконкатенированное содержимое всех текстовых потомков  
Имеет смысл при пользовательском вводе (даже если вводим теги - они будут текстом)  
`elem.innerText` - везде кроме Firefox, и работает немного иначе (будто
мы выделили кусок текста мышью - что не видно того не будет)  
`elem.hidden` - определяет, виден элемент или нет (не раб. в IE10-)  

Есть и другие свойства, зависящие от типа, например:  
 * `value` — значение для INPUT, SELECT или TEXTAREA
 * `id` — идентификатор
 * `href` — адрес ссылки
 * …многие другие…

#### Атрибуты и DOM-свойства
`document.body.someVar = 0/false/function` - это DOM-свойство  
`<tag attr="0">` - это атрибут  

Доступ к атрибутам:
 - `elem.hasAttribute(name)` – проверяет наличие атрибута
 - `elem.getAttribute(name)` – получает значение атрибута
 - `elem.setAttribute(name, value)` – устанавливает атрибут
 - `elem.removeAttribute(name)` – удаляет атрибут
 - `elem.attributes` - возвращает псевдомассив элементов типа `Attr`

В отличие от свойств, атрибуты:
  - Всегда являются строками.
  - Их имя нечувствительно к регистру (ведь это HTML)
  - Видны в `innerHTML` (за исключением старых IE)

Все, что мы устанавливаем в атрибут - приводится к строке  

Атрибуты и свойства **не всегда** имеют одно и то же значение:
```JavaScript
a.href = '/';
a.getAttribute('href'); // '/'
a.href;  // полный URL
```
Чаще синхронизация — односторонняя: свойство зависит от атрибута, но не наоборот.  
Для нестандартных атрибутов DOM-свойство не создается.


Атрибуту `"class"` соответствует свойство `className` (а еще `classList`).  
`elem.classList.contains("class")`  
`elem.classList.add/remove("class")`  
`elem.classList.toggle("class")`  

Атрибуты `data-*` зарезервированы для пользовательских данных (HTML5).  
Из жс к ним можно обратиться через `elem.dataset.*`  
При этом дефисное написание превратится в camelCase:  
```JavaScript
<tag data-pizdets-govho="777">
elem.dataset.pizdetsGovno; //777
```

Свойство/атрибут `hidden` не поддерживается в IE11.

`parent.contains(child)` вернет true если parent содержит child, или
parent == child  
`nodeA.compareDocumentPosition(nodeB)` вернет побитово:
 - **0**	- nodeA и nodeB — один и тот же узел
 - **1**	- Узлы в разных документах (или один из них не в документе)
 - **2**	- nodeB предшествует nodeA (в порядке обхода документа)
 - **4**	- nodeA предшествует nodeB
 - **8**	- nodeB содержит nodeA
 - **16**	- nodeA содержит nodeB
 - **32**	- Зарезервировано для браузера

В IE8- свои фишки последними двумя методами

# Доделать:
https://learn.javascript.ru/modifying-document
https://learn.javascript.ru/multi-insert

#### Метод document.write
Метод `document.write(str)` работает только пока HTML-страница находится
в процессе загрузки. Он дописывает текст в текущее место HTML ещё до того,
как браузер построит из него DOM.  
Нет никаких ограничений на содержимое document.write.  
Технически, вызвать document.write можно в любое время, однако, когда
HTML загрузился, и браузер полностью построил DOM, документ становится
«закрытым». Попытка дописать что-то в закрытый документ открывает его заново.
При этом все текущее содержимое удаляется.  
Если заданы `Content-Type: text/xml` или `Content-Type: text/xhtml+xml`,
то document.write не работает.  
**Преимущества document.write**:
 - охуенно быстрый
 - не проверяет содержимое

**На заметку:**
```JavaScript
document.write('<script src="' + url + '"></script>'); //ошибка!
//браузер увидит '</script>' и подумает что это конец скрипта

//рабочие варианты:
document.write('<script src="' + url + '"></scr' + 'ipt>');
document.write('<script src="' + url + '"><\/script>');
```

### Стили элемента
`element.style` возвращает объект, который дает доступ к стилю элемента на
чтение и запись.  
Для свойств с дефисным написанием здесь используется camelCase.  
> 'float' в жс будет выглядеть так: `elem.style.cssFloat`  
'-moz-border-radius', '-webkit-border-radius' записываются как
`MozBorderRadius`, `WebkitBorderRadius`  

Чтобы сбросить поставленный стиль, присваивают в style пустую строку:
`elem.style.width=""`  
Свойство `style.cssText` позволяет поставить стиль в виде строки, как мы
пишем в css. При его установке все предыдущие выставленные свойства удаляются.  
Прочитать из style скорее всего ничего не получится, т.к. при его чтении не
учитывается каскад, выводит лишь то, что задано в стиле элемента.  
Чтобы прочитать фактический стиль, есть метод  
`getComputedStyle(element[, pseudo])` (не работает в IE8-)  

В CSS есть две концепции:  
 1. Вычисленное (computed) значение - то, что можно видеть в devTools
 2. Окончательное (resolved) значение - приведенное к пикселям

В большинстве случаев `getComputedStyle` вернет оканчательное значение.  
Этот метод требует полное свойство (не 'margin', а 'marginTop' etc.)!  Если
задать не полное, то хз что вернет (может вернет, а может и нет). Например,
если paddingLeft взят из одного источника, а paddingRight из другого - то скорее
всего не склеит нормально.  
> К свойствам a:visited из жс не добраться. В целях безопасности.  

В IE8- как обычно своя атмосфера.  

### Метрики окна
[Все что надо, с пиздатыми иллюстрациями](https://learn.javascript.ru/metrics)  
Метрики для невидимых элементов равны нулю.  
`offsetParent` — «родитель по дереву рендеринга» — ближайшая ячейка таблицы,
body для статического позиционирования или ближайший позиционированный элемент
для других типов позиционирования.  
`offsetLeft/offsetTop` — позиция в пикселях левого верхнего угла блока,
относительно его offsetParent.  
`offsetWidth/offsetHeight` — «внешняя» ширина/высота блока, включая рамки.  
`clientLeft/clientTop` — отступ области содержимого от левого-верхнего угла
элемента. Если операционная система располагает вертикальную прокрутку справа,
то равны ширинам левой/верхней рамки, если же слева (ОС на иврите, арабском),
то clientLeft включает в себя прокрутку.  
`clientWidth/clientHeight` — ширина/высота содержимого вместе с полями padding,
 но без полосы прокрутки.  
`scrollLeft/scrollTop` — ширина/высота прокрученной части документа, считается
от верхнего левого угла.  
`scrollWidth/scrollHeight` — ширина/высота содержимого, включая прокручиваемую
 область. Включает в себя padding и не включает полосы прокрутки.  

Пока на этом остановился
