`console.log` и `console.dir` - разные выводы (пробовать на HTML-объектах)

`window` содержит свойства и методы для управления окном браузера, открытия
новых окон...

`document` даёт возможность взаимодействовать с содержимым страницы.

**BOM** — это объекты для работы с чем угодно, кроме документа:
 - `navigator`
 - `screen`
 - `location`
 - `frames`
 - `history`
 - `XMLHttpRequest`

`navigator` содержит общую информацию о браузере и операционной системе.
Особенно примечательны два свойства:  
`navigator.userAgent` — содержит информацию о браузере  
`navigator.platform` — содержит информацию о платформе,
позволяет различать Windows/Linux/Mac  
`alert`/`confirm`/`prompt` — тоже входят в BOM


# DOM
Всего различают 12 типов узлов, но на практике мы работаем с четырьмя из них:
 1. **Документ** — точка входа в DOM.
 2. **Элементы** — основные строительные блоки.
 3. **Текстовые узлы** — содержат, собственно, текст.
 4. **Комментарии** — иногда в них можно включить информацию, которая не будет
 показана, но доступна из JS.

```JavaScript
document.documentElement; //HTML
document.head; // <head>...</head> // IE9+
document.body; // <body>...</body>
```
> _Тонкость_: если скрипт выполняется до того, как загрузился **body**, то
`document.body == null`  
И вообще, если какой-то элемент не определен, то в операциях с DOM возвращается
`null`, а не `undefined`

### Навигация по DOM
> Здесь и далее:
**дети** - потомки первого уровня  
**потомки** - все потомки

`elem.childNodes` - массив с детьми, константный метод  
Данный метод возвращает не JS-массив, а "коллекцию". Всякие filter и прочее
работать не будут. Для того чтобы это сделать есть два метода:
 1. `Array.prototype.method.call`
 2. `var arr = Array.prototype.slice.call(collection);`

> **Для обхода коллекции нельзя использовать `for in` !!!**


`elem.firstChild` - первый потомок  
`elem.lastChild` - последний потомок  
`elem.previousSibling` - следующий "брат"  
`elem.nextSibling` - предыдущий "брат"  
`elem.parentNode` - родитель  
`elem.hasChildNodes` - проверка, есть ли детки

Есть аналогичные методы, которые не включают текстовые узлы:  
`elem.children`  
`elem.firstElementChild`  
`elem.lastElementChild`  
`elem.previousElementSibling`  
`elem.nextElementSibling`  
`elem.parentElement`  

Отличие `elem.parentNode` от `elem.parentElement`:
```JavaScript
document.documentElement.parentNode; // document
document.documentElement.parentElement; // null
```
> В IE8- из всего этого есть только `children`, причем в возвращенной коллекции
будут и узлы-комментарии

#### Особые ссылки таблиц
`table.rows` — коллекция строк TR таблицы.  
`table.caption/tHead/tFoot` — ссылки на элементы таблицы CAPTION, THEAD, TFOOT.  
`table.tBodies` — коллекция элементов таблицы TBODY,
по спецификации их может быть несколько.  
`tbody.rows` — коллекция строк TR секции  
`tr.cells` — коллекция ячеек TD/TH  
`tr.sectionRowIndex` — номер строки в текущей секции THEAD/TBODY  
`tr.rowIndex` — номер строки в таблице  
`td/th.cellIndex` — номер ячейки в строке  

### Поиск элемента
#### По id
Как делать не надо:
```HTML
<div id="content-holder">
  <div id="content">Элемент</div>
</div>

<script>
  alert( content ); // DOM-элемент
  alert( window['content-holder'] ); // в имени дефис, поэтому через [...]
</script>
```
Такое поведение существует лишь для обратной совместимости. Для выдергивания
элемента по id используем  
`document.getElementById("идентификатор")`  
Таким образом можем искать только внутри `document`
> Если вдруг в документе несколько узлов с заданным id, то поведение не
определено (какой попадется: первый, последний - хуй знает)

#### По тегу
`elem.getElementsByTagName(tag)` - возвращает список потомков с нужным тегом  
Этим методом мы можем получить всех потомков, передав `*` вместо tag

#### По name
Используется редко, но такой метод есть:  
`document.getElementsByName('age')` - возвращает список элементов
с атрибутом name равным 'age'

### По классу
`document.getElementsByClassName('article')` - вернет список элементов
с заданным классом (если у элемента несколько классов и хоть один из
них подходит - то элемент подходит)

### По селектору
`elem.querySelectorAll(selector)` - вернет список элементов,
удовлетворяющих css-селектору
`elem.querySelector(selector)` - все равно что
`elem.querySelectorAll(selector)[0]`,
но сработает быстрее  
`elem.matches(selector)` - проверяет, удовлетворяет ли данный элемент
селектору  
Ранее в спецификации он назывался `matchesSelector`, и большинство браузеров
поддерживают его под этим старым именем, либо с префиксами ms/moz/webkit
`elem.closest(css)` - ищет ближайший подходящий под селектор родитель
(включая сам элемент)  
Также есть поиск элементов через `XPath`, но это пиздец как сложно
и вообще нужно для XML  
`get\*` работает очень быстро, т.к. браузер хранит внутренне соответствие
id -> элемент.  
#### Как работает поиск
https://learn.javascript.ru/searching-elements-internals  
`querySelector` тупо перебирает потомков узла. Внутри браузеров имеются
оптимизации (например, `querySelector('#id')` превращается в
`getElementById`, результаты поиска кешируются до изменения документа...)  
Результат поиска `getElementsBy*` изменяется в соответствии с изменением
документа. Дело в том, что `getElementsBy*` возвращают не массив,
а специальный объект типа `NodeList` или `HTMLCollection`, который представляет
собой не готовую коллекцию, а "живой поисковый запрос"

### DOM-узел
**Разные узлы являются объектами различных классов.**
Поэтому, к примеру, у узла, соответствующего тегу `<td>` — одни свойства, у
`<form>` — другие, у `<a>` — третьи.  
`elem.nodeType` вернет тип узла (их всего 12, где элемент - 1, текст - 3).
Метод работает только на чтение  
`elem.nodeName` вернет для элементов - имя тега, для не-элементов -
строку с типом узла  
`elem.tagName` вернет имя тега (для HTML - всегда капсом)
`elem.innerHTML` - внутреннее содержимое элемента в виде строки (можно
читать и писать)  
> `elem.innerHTML +=` осуществляет перезапись всего innerHTML!  
Все изображения и другие ресурсы будут перезагружены!  
Скрипты не выполнятся!  
Все введенное в инпуты сбросится!  
Выделение пропадет!  

`elem.outerHTML` - вернет весь контент элемента (включая сам элемент)  
Теоретически это свойство доступно на запись, но при этом элемент не меняется,
а заменяется на новый, а переменная в которую мы записали старый HTML остается
как была.  

`elem.data` - вернет контент текстовых/комментовых узлов (rw)  
`elem.nodeValue` - как прошлый, но вместо `undefined` вернет `null` (rw)  
`elem.textContent` - вернет сконкатенированное содержимое всех текстовых потомков  
Имеет смысл при пользовательском вводе (даже если вводим теги - они будут текстом)  
`elem.innerText` - везде кроме Firefox, и работает немного иначе (будто
мы выделили кусок текста мышью - что не видно того не будет)  
`elem.hidden` - определяет, виден элемент или нет (не раб. в IE10-)  

Есть и другие свойства, зависящие от типа, например:  
 * `value` — значение для INPUT, SELECT или TEXTAREA
 * `id` — идентификатор
 * `href` — адрес ссылки
 * …многие другие…

#### Атрибуты и DOM-свойства
`document.body.someVar = 0/false/function` - это DOM-свойство  
`<tag attr="0">` - это атрибут  

Доступ к атрибутам:
 - `elem.hasAttribute(name)` – проверяет наличие атрибута
 - `elem.getAttribute(name)` – получает значение атрибута
 - `elem.setAttribute(name, value)` – устанавливает атрибут
 - `elem.removeAttribute(name)` – удаляет атрибут
 - `elem.attributes` - возвращает псевдомассив элементов типа `Attr`

В отличие от свойств, атрибуты:
  - Всегда являются строками.
  - Их имя нечувствительно к регистру (ведь это HTML)
  - Видны в `innerHTML` (за исключением старых IE)

Все, что мы устанавливаем в атрибут - приводится к строке  

Атрибуты и свойства **не всегда** имеют одно и то же значение:
```JavaScript
a.href = '/';
a.getAttribute('href'); // '/'
a.href;  // полный URL
```
Чаще синхронизация — односторонняя: свойство зависит от атрибута, но не наоборот.  
Для нестандартных атрибутов DOM-свойство не создается.


Атрибуту `"class"` соответствует свойство `className` (а еще `classList`).  
`elem.classList.contains("class")`  
`elem.classList.add/remove("class")`  
`elem.classList.toggle("class")`  

Атрибуты `data-*` зарезервированы для пользовательских данных (HTML5).  
Из жс к ним можно обратиться через `elem.dataset.*`  
При этом дефисное написание превратится в camelCase:  
```JavaScript
<tag data-pizdets-govho="777">
elem.dataset.pizdetsGovno; //777
```

Свойство/атрибут `hidden` не поддерживается в IE11.

#### Проверка на дочернесть  
`parent.contains(child)` вернет true также если parent === child

`nodeA.compareDocumentPosition(nodeB)` вернет битовую маску  
 - **0** - _nodeA_ и _nodeB_ — один и тот же узел
 - **1** - Узлы в разных документах (или один из них не в документе)
 - **2** - _nodeB_ предшествует _nodeA_ (в порядке обхода документа)
 - **4** - _nodeA_ предшествует _nodeB_
 - **8** - _nodeB_ содержит _nodeA_
 - **16** - _nodeA_ содержит _nodeB_
 - **32** - Зарезервировано для браузера

В IE8-, как обычно, своя атмосфера

#### Создание/удаление узлов  
 - `document.createElement(tag)` — создает элемент
 - `document.createTextNode(value)` — создает текстовый узел
 - `elem.cloneNode(deep)` — клонирует элемент, если deep == true, то со всеми 
 потомками, если false — без потомков.
 - `parent.appendChild(elem)`
 - `parent.insertBefore(elem, nextSibling)`
 - `parent.removeChild(elem)`
 - `parent.replaceChild(newElem, elem)`

Все эти методы возвращают elem.

 - `elem.insertAdjacentHTML(where, html)` - _where_ принимает значения:
   - `beforeBegin` — перед elem.
   - `afterBegin` — внутрь elem, в самое начало.
   - `beforeEnd` — внутрь elem, в конец.
   - `afterEnd` — после elem
 - `elem.insertAdjacentElement(where, newElem)`
 - `elem.insertAdjacentText(where, text)` 

Эти методы не работают в FF8-  

`var fragment = document.createDocumentFragment()` создает недо-узел (у него 
нет innerHTML, tagName и много чего еще). Но ему можно надобавлять детей, а потом
впихнуть это все одной пачкой в наш документ. При этом сам фрагмент исчезает,
на это место добавляются его дети. Имеет смысл только в больших вставках, и то
надо бенчмаркать.

Относительно новые методы из стандарта:
 - `node.append(...nodes)` — вставляет nodes в конец node,
 - `node.prepend(...nodes)` — вставляет nodes в начало node,
 - `node.after(...nodes)` — вставляет nodes после узла node,
 - `node.before(...nodes)` — вставляет nodes перед узлом node,
 - `node.replaceWith(...nodes)` — вставляет nodes вместо node.

Эти методы ничего не возвращают.

#### `document.write()`
Один из самых древних методов. Просто дописывает что-то в текущее место HTML.  
Работает только тогда, когда страница еще не прогрузилась.  
В страницах с `Content-Type: text/xml` или `Content-Type: text/xhtml+xml` метод
не работает.  
Этот метод работает **охуенно быстро**. Но его лучше не использовать, он ничего
не проверяет.

### Стили  
Свойство `element.style` возвращает объект, который дает доступ к стилю 
элемента на чтение и запись.
> Возвращает все с единицами измерения, как в css. Устанавливать значения тоже
**обязательно** с единицами измерения.  

Дефисная запись свойств переводится в camelCase.  
> `style.cssFloat` вместо `style.float`,  
`-moz-border-radius` => MozBorderRadius,  
`-webkit-border-radius` => WebkitBorderRadius  

Чтобы сбросить стиль - устанавливаем пустую строку.  

Для установки стилей строкой юзаем `style.cssText` - получится охуенно 
кроссбраузерно. Но все предыдущее, установленное через `elem.style` - сбросится.
`style.cssText = "border: 1px solid red;"`

На чтение `elem.style` вернет лишь установленное в коде свойство элемента, без 
учета каскада css.  
Чтобы узнать вычисленное, делаем 
`getComputedStyle(element[, pseudo])` вместо `elem.style`:
```JavaScript
var computedStyle = getComputedStyle(document.body);
alert( computedStyle.marginTop ); // выведет отступ в пикселях
```

Значения могут быть:
 1. Вычисленными (computed) - width: auto или font-size: 125%
 2. Окончательными (resolved) - возвращает все в пикселях  

Чаще всего возвращаются окончательные значения.  
Обязательно нужно получать точно то, что хотим (marginTop вместо margin например)  
> Стили посещенных ссылок (_:visited_) получить нельзя! Безопасность и все такое

В IE8- как обычно.

### Геометрия элемента
![Elem geometry](https://ru.js.cx/article/metrics/metric-css.png)

#### Метрики
![Window metrics](https://ru.js.cx/article/metrics/metric-all.png)

`offsetParent`, `offsetLeft/Top` - если их пришлось использовать - значит я 
говнокодю.
