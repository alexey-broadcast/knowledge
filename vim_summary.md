ultisnip
Встроенную документацию смотреть так:  
`:help something` или `:h something`

# Command-line mode
|Команда | Что делает|
|:------:|:----------|
| `@:` | повторить последнюю Ex-команду  |
| `:` | Ex command  |
| `/` | forward search  |
| `?` | backward search  |
| `=` | Vim script expression  |
| `@:` | повторить последнюю команду  |
| `:s/target/replacement` | поиск с заменой в текущей строке |
| `:%s/target/replacement` | поиск с заменой по всему файлу, но заменится только первое вхождение в строке |
| `:%s/target/replacement/g` | поиск с заменой по всему файлу  |
| `:qall!` | выйти из vim не сохраняя все файлы
| `:wall` | сохранить все
| `:{number}` | перейти на строку №{number}.
| `:p`, `:print` | распечатать
| `:d`, `:delete` | удалить
| `:t`, `:co`, `:copy`	 | скопировать
| `:m`, `:move`	 | переместить
| `:bn`, `:bnext`	 | перейти в следующий буфер
| `:bp`, `:bprevious`	 | перейти в предыдущий буфер
| `<C-r><C-w>`	 | скопировать слово под курсором и вставить в командную строку
| `<C-r><C-a>`	 | скопировать СЛОВО под курсором и вставить в командную строку
| `<Up>` или `<Down>`	 | перемещение по истории команд (работает с `:`, `/` etc.)
| `:!{command}`  | запустить shell-команду
| `:shell`  | запустить виртуальный shell, выйти из него - вводим `exit`
| `:read {filename}`  | вставить содержимое файла под курсор
| `:read !{cmd}`  | вставить вывод команды под курсор
| `:write !{cmd}`  | подать содержимое буфера на вход команды
| `:write! {something}`  | перезаписать содержимое файла something содержимым буфера
| `[range]!{filtercommand}`  | перезаписать range выводом команды, подавая команде на вход строки из range

Можно сочетать движения с другими командами:  
`:3p` - распечатать третью строку    
`:3,10d` - удалить строки с 3 по 10 включительно    
Вместо номера текущей строки можно поставить `.`    
Конец файла - `$`    
`%` - все равно что `1,$`  
Если перейти в command-line из **visual mode**, то строка будет начинаться с `:'<,'>` - это означает выделение  
Можно вместо номера строки ввести паттерн поиска: 
`:/<html>/,/<\/html>/p` распечатает весь текст внутри тегов html (строк с найденным, включая эти строки)  
Допускается арифметика вида `{address}+n`. Например: `:/<html>/+1,/<\/html>/-1p` выведет 
текст внутри тегов html, но не включая строки с самими тегами.  
Адрес `0` как бы не существует, но возможен и полезен когда нам надо перенести или скопировать
что-то в начало файла
`'m` - строка, которая содержит mark m

**Пример**:  
`:6t.` - скопировать строку 6 под текущую


Можно использовать **normal mode**-команды через `:normal`:    
`:%normal A;` - прибавить в конец каждой строки `;`  
В таких командах курсор всегда переходит в начало строки:  
`:%normal i//` - прибавить в начало каждой строки `//`


**Рабочие команды из Insert mode**:
 - `<C-w>`
 - `<C-u>`
 - `<C-v>`
 - `<C-k>`
 - `<C-r>`

`:noh` - снять подсветку результатов поиска

## Command-line window 
Открывается через `q:`. Дает возможность перемещаться по истории команд, менять их прямо там и запускать
через `<CR>`. Выйти из него можно только запустив команду, или набрав `:q`.  
Если мы находимся в **Command-line mode**, то переключиться на **Command-line window** 
без потери уже введенной команды можно через `<C-f>`

# Normal mode
`.` - повторить последнюю команду
`*` ( = `/\< <C-r><C-w> \> <CR>`) - перейти к следующему вхождению слова под курсором

## Команды
Чтобы применить команду к текущей строке, мы можем ее просто дважды тыцкнуть:
`dd`, `yy`, `gUU`  

|Команда | Синоним | Перевод | Что делает|
|:------:|:-------:|:-------:|:----------|
| `a` |  | append | перейти в **insert mode** после курсора
| `i` |  | insert | перейти в **insert mode** перед курсором
| `v` |  | visual | перейти в **visual mode**(посимвольный) перед курсором
| `V` |  | visual | перейти в **visual mode**(построчный) перед курсором
| `<C-v>` |  | visual | перейти в **visual mode**(блочный) перед курсором
| `gv` |  | | выделить последнее выделение (можно get confused если этот текст удален)
| `d{motion}`  |  | delete | удалить {motion}
| `x` | `dl` | delete char | удалить символ под курсором
| `c{motion}`  | `d{motion}i` | change | удалить {motion} и перейти в **insert mode**
| `s`  | `xi` | subst char | удалить символ под курсором и перейти в **insert mode**
| `>{motion}`  |  |  | увеличить отступ
| `<{motion}`  |  |  | уменьшить отступ
| `=`  |  |  | autoindent
| `A`  | `$a` |  | перейти в **insert mode** в конце строки
| `C`  | `c$` |  | удалить до конца строки и перейти в **insert mode**
| `S`  | `^C` |  | удалить всю строку и перейти в **insert mode**
| `I`  | `^i` |  | перейти в **insert mode** в начале строки
| `o`  | `A<CR>` |  | добавить строку после и перейти в **insert mode**
| `O`  | `ko` |  | добавить строку перед и перейти в **insert mode**
| `u`  |  | undo | отменить последнюю команду
| `g~{motion}` |  |  | inverse case
| `gu{motion}` |  |  | lower case
| `gU{motion}` |  |  | upper case
| `{number}G`  |  |  | перейти на строку №
| `!{motion}`  |  |  | перейти в **Command-line mode** с заранее введенным range
| `m{a-z}`  | mark |  | поставить закладку локальную для текущего буфера
| `m{A-Z}`  | mark |  | поставить закладку глобальную для всего вима

## Предлоги
|Команда | Перевод | Пример | Что делает|
|:------:|:-------:|:------:|:----------|
| `a` | around | `daw` | delete a word (удаляет слово вместе с пробелами)
| `i` | inner | `diw` | delete inner word (удаляет слово без пробелов)

## Движения
Движение `g[hjkl]` будет по _видимой_ строке, а не фактической.  
`H`/`M`/`L` - верх/середина/низ экрана
Поиск через `/` тоже может работать как движение.  

|Команда | Синоним | Перевод | Что делает|
|:------:|:-------:|:-------:|:----------|
| `w` |  | word | вперед до начала след. слова
| `b` |  | begin | до начала слова
| `e` |  | end | вперед до конца слова
| `ge` |  |  | назад до конца пред. слова
| `W` |  | word | вперед до начала след. СЛОВА
| `B` |  | begin | до начала СЛОВА
| `E` |  | end | вперед до конца СЛОВА
| `gE` |  |  | назад до конца пред. СЛОВА
| `gi` |  | go to insert | перейти к месту последнего изменения
| `g;` |  | | перейти к месту предыдущего изменения
| `g,` |  | | перейти к месту следующего изменения
| `s` |  | sentence | 
| `p` |  | paragraph | 
| `$` |  |  | до конца строки
| `G` |  |  | до конца буфера
| `f{char}`  |  | find | переместить курсор к ближайшему символу {char} вперед в строке
| `t{char}`  | `f{char}h` | till | переместить курсор к ближайшему символу {char} вперед в строке
| `F{char}`  |  | find | переместить курсор к ближайшему символу {char} назад в строке
| `T{char}`  | `F{char}l` | till | переместить курсор к ближайшему символу {char} назад в строке
| `;`  |  |  | повторить последний find
| `n`  |  | next | следующий результат поиска в **command-line mode**
| `N`  |  | next | предыдущий результат поиска в **command-line mode**
| `(`/`)`  |  |  | перейти к началу пред./след. **предложения**
| `{`/`}` |  |  | перейти к началу пред./след. **абзаца**
| `>`  |  |  | текст, заключенный в <>
|  |  |  | то же самое для кавычек, прочих скобок. `vi}` выделит текст внутри, `vat` выделит вместе с тегом. `)` = `b`, `}` = `B`
| `t`  |  |  | текст, заключенный в HTML-теги
| ``` `{char} ```  | |  | перейти к закладке`
| `'{char}`  | |  | перейти к строке с закладкой
| ``` `` ```  | |  | перейти в место **перед последним прыжком**
| ``` `. ```  | |  | перейти в место **последнего изменения**
| ``` `^ ```  | |  | перейти в место **последней вставки**
| ``` `[ ```  | |  | start of **last change or yank**
| ``` `] ```  | |  | end of **last change or yank**
| ``` `< ```  | |  | start of **last visual selection**
| ``` `> ```  | |  | end of **last visual selection**
| `<C-]>` | | | перейти к определению **кейворда** под курсором
| `gf` |  | go to file | перейти к **файлу** под курсором

## Регистры
Перед командой можно указать регистр, в который запишется: `"{char}` и дальше  
остальная команда, например: `"add` удалит строку и занесет ее в регистр _a_.  
Дефолтный регистр - `"`,  
yank - `"0` (в него попадает все из `y`)  
black hole - `"_` (из него ничегошеньки не возвращается)
системный clipboard - `"+`
системный буфер Х11, который работает с выделением и средней кн. мыши - `"*`. 
В винде и маке это тот же системный клипборд
expression register - `"=` - TODO
`"%` - Name of the current file
`"#` - Name of the alternate file
`".` - Last inserted text
`":` - Last Ex command
`"/` - Last search pattern  

Если мы что-то выделили в **Visual mode**, то можем вставить - и тогда выделение  
заменится. Но тогда в регистр попадет выделение (т.е. тексты как бы поменяются
местами).


## Прочие команды
|Команда | Что делает|
|:------:|:----------|
| `<C-a>`  | найти первое число после курсора и прибавить к нему единицу
| `<C-x>`  | найти первое число после курсора и отнять от него единицу
| `ga`  | вывести внизу код символа под курсором
| `gR`  | **Virtual Replace mode**
| `r` | перейти в _single-shot_-**replace mode**
| `gr` | перейти в _single-shot_-**virtual replace mode**
| `<C-g>`  | отобразить имя файла и длину в статусбаре
| `<C-o>`  | назад в jump-листе
| `<C-i>`  | вперед в jump-листе
| `g;`, `g,`  | назад-вперед в change-листе

### Surround-vim
Помогает при работе с парными символами и HTML-тегами  

|Команда | Что делает|
|:------:|:----------|
| `ds{pair_symbol}`  | удалить окружающие парные символы
| `cs{pair_symbol_before}{pair_symbol_after}`  | заменить окружающие парные символы
|  | в after подавать тег: cs"<p> заменит окружающие на тег
|  | в before подавать `w` или `W`: csw" поместит слово в кавычки
| `ys{motion}{pair_symbol}`  | добавить окружающие парные символы
| `yss{pair_symbol}`  | добавить окружающие парные символы ко всей строке
| `ySS{pair_symbol}`  | добавить окружающие парные символы ко всей строке, расставив скобки на отдельных строках
| Insert mode: `<C-s>`  | добавить окружающие парные символы (?TODO)


# Insert mode
|Команда | Синоним | Что делает|
|:------:|:-------:|:----------|
| `<Insert>` |  | Toggle **Insert**/**Replace** mode
| `<C-h>` | `<Backspace>` | Стирает символ перед курсором
| `<C-w>` | | Стирает слово
| `<C-u>` | | Стирает до начала строки
| `<C-[>` | `<Esc>` | Переход в **normal mode**
| `<C-o>` | | Переход в **insert normal mode**
| `<C-r>{register}` |  | вставить из регистра
| `<C-r>{expression}` |   | вычислить выражение и вставить результат
| `<C-v>{code}` |   | вставить символ по коду (напр.: `065` - 3 цифры обязательно!, `u00f9` - перед юникодом ставим 'u', 2 буквы - символ по диграфу)


## Insert normal mode
Позволяет ввести одну **normal mode**-команду , после чего автоматически переходит в **insert mode**


## Virtual Replace mode
Позволяет заменять символы, при этом например таб разбивает на пробелы чтобы не было путаницы

# Visual mode
В **Visual mode** работает большинство команд из **Normal mode**, только прикол в том, что
если _{motion}_ не нужен, его роль исполняет выделение.

**Пример**: `viw` - выделить слово

|Команда | Что делает|
|:------:|:----------|
| `o`  | перейти в другой конец выделения
| `u`  | закапсить
| `U`  | раскапсить

**Рабочие команды перехода в Insert mode**  
 - `r`
 - `c`
 - `I` - вставить после выделения
 - `A` - вставить до выделения
`i`, `a` на переход в Insert mode не работают, т.к. в Visual mode они означают предлоги _a_, _inner_

# Макросы
`q{char}`/`q` - начать/остановить запись макроса  
`q{CHAR}` - если букву закапсить - то введенноое содержимое _добавится_ к регистру.
`@{char}` - выполнить макрос  
`@@` - выполнить последний макрос  
Если команда движения фейлит (например `j` на последней строке или `n` ничего 
не нашел) - то макрос прекращает работу. Можно таким образом делать проверку,
стоит ли продолжать работу, и потом делать over9000@@. А можно выделить кучу
строк и запустить для них макрос `:'<,'>normal @{char}`.
Лучше начинать макрос с позиционирования например в `0` начале строки, или 
`n` следующем найденном
`:reg {char}` - показать записанный макрос.
Служебные клавиши записываются ебанистически: _Esc_ => `^[`, _Backspace_ => `<80>kb`  
Регистры используются те же самые, что и для вставки/удаления, т.е. мы можем
скопировать в регистр какие-то символы, и затем воспроизвести их как макрос.

# Работа с несколькими файлами

|Команда | Синоним | Что делает|
|:------:|:-------:|:----------|
| `:ls`  | | просмотреть список буферов. Текущий буфер помечен `%a`, предыдущий - `#`. Измененный файл - `+`
| `<C-^>`  | | метнуться между текущим и предыдущим
| `:bnext` | `:bn` | следующий буфер
| `:bfirst` | `:bf` | первый буфер
| `:blast`  | `:bl` | последний буфер
| `:buffer {number}` `:buffer {filename}` | `:b {число или имя}` | перемещение между буферами. Имя должно содержать символы, достаточные для однозначной идентификации.
| `:bdelete {N1} {N2} ...` | `:bd...` | закрыть буфер (без сохранения)
| `:{N1},{N2}bdelete` | `:{range}bd` | закрыть буферы (без сохранения)
| `:bdelete {N1} {N2} ...` | `:bd...` | закрыть буфер (без сохранения)
|  |  |  
| `:args` |  | показать список _аргументов_. [] показывает, какой из файлов в данный момент активен (?TODO)
| `:args {filenames}` |  | задать список _аргументов_. Можно `*` и `**`. Можно консольную команду в обратных кавычках.
| `:next` |  | перейти к следующему аргументу
| `:prev` |  | перейти к предыдущему аргументу
| `:argdo {cmd}` |  | исполнить команду на всех аргументах
| `:bufdo {cmd}` |  | исполнить команду на всех буферах
|  |  |  
| `<C-w>s` |  | split horizontal 
| `<C-w>v` |  | split vertical 
| `:sp[lit] {file}` |  | split horizontal
| `:vsp[lit] {file}` |  | split vertical
| `:cl[ose]`, `<C-w>c` |  | Close the active window
| `:on[ly] `, `<C-w>o` |  | Keep only the active window, closing all others
| `<C-w>=` |  | Equalize width and height of all windows
| `<C-w>_` |  | Maximize height of the active window
| `<C-w>|` |  | Maximize width of the active window
| `[N]<C-w>_` |  | Set active window height to [N] rows
| `[N]<C-w>|` |  | Set active window width to [N] columns

# Конфиги
`set suffixesadd+=.h` - работает для открытия файлов. Самоподставляет к именам расширения.  
`set path=.,**,/usr/bin` - работает для открытия файлов. Папки, в которых ищет.  
`set exrc` - говорит виму читать еще файл с настройками в открываемой папки.  
