=========== learn.javascript.ru ============

ПЕРЕПРОЧИТАТЬ:
1.	https://learn.javascript.ru/array-iteration

2.	бинарный + например массива и числа к чему приводит?
		приводит к строке

3.		var a = new function() {
		  	this.b = 2;
		} //работает как конструктор
		alert(a.b);

4.	https://learn.javascript.ru/oop-errors

Численное преобразование
	переопределяем метоод valueOf(). не обязательно возвращать number, любой примитив
	(string, bool etc) который потом будет преобразован к число

Строковое преобразование
	Кастомное преобразование к строке получается переопределением метода toString()
	оно может возвращать любой примитив, не обязательно string. Потом это к строке
	приведется дополнительно


Автоматическое тестирование:
	https://learn.javascript.ru/testing

Массивы:

	split(symbol, num):
		"a,b,c,d".split(',', 2); // 'a', 'b'
		"abcd".split(''); // 'a', 'b', 'c', 'd'
	join(sym):
		[1, 2, 3].join('+'); // '1+2+3'
		new Array(4).join("ля"); // ляляля
	splice(index[, deleteCount, elem1, ..., elemN]):
		var arr = ["Я", "изучаю", "JavaScript"];
		var res = arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
		res; // [ 'изучаю' ]
		arr; // ["Я", "JavaScript"]

		var arr = ["Я", "изучаю", "JavaScript"]; //вставка элементов
		arr.splice(2, 0, "сложный", "язык");
		arr; // "Я", "изучаю", "сложный", "язык", "JavaScript"

		//отрицательные номера отсчитываются с конца
	slice(begin, end): копирует участок массива от begin до end, не включая end.
	 Исходный массив при этом не меняется
	sort(): по умолчанию приводит все к строке
		sort(function(a, b) {
			//Она должна возвращать:
			//Положительное значение, если a > b,
			//Отрицательное значение, если a < b,
			//Если равны — можно 0, но вообще — не важно, что возвращать, их взаимный порядок не имеет значения.
		})
	reverse()
	concat(param1, param2 ...): param может быть массивом, тогда добавится не массив, а элементы из массива
		var arr = [1, 2];
		var newArr = arr.concat([3, 4], 5); //[1, 2, 3, 4, 5]
	indexOf(searchElement[, fromIndex]) - используется строгое сравнение ===
	lastIndexOf(searchElement[, fromIndex]) - используется строгое сравнение ===

Date, Time:
	new Date(msecs) - c 01.01.1970 GMT+0
	new Date(datestring)
	new Date(year, month, date, hours, minutes, seconds, ms) - первые два обязательны
	 остальные - (year, month, date=1, hours=0, minutes=0, seconds=0, ms=0)
	 year - 4 цифры, month = от 0 до 11
	getFullYear(), getMonth(), getDate(), getHours(), getMinutes(), getSeconds(), getMilliseconds()
	getDay() - номер дня в неделе от 0 до 6
	есть аналогичные сеттеры, есть все эти методы в UTC (GMT+0)
	toLocaleString(локаль, опции)
	toString(), toDateString(), toTimeString()
	parse(str)
	now(): он аналогичен вызову +new Date(), но в отличие от него
	 не создаёт промежуточный объект даты, а поэтому — во много раз быстрее
	при бинарном + используется toString, а не valueOf


Цикл:
	решение задачки:
		for (var i = 0; i < 10; i++) {
		    var shooter = function(cur) {
		    	return function() { // функция-стрелок
		      		alert( cur ); // выводит свой номер
		    	};
		    } (i);
		    shooters.push(shooter);
		}

Декораторы:
		function decorate(f) {
		  return function() {
		    return f.apply(this, arguments);
		  }
		}
		function Func() {};
		Func = decorate(Func);


  Декоратор для проверки типов входных данных:
  	https://learn.javascript.ru/decorators
  	Можно использовать чтобы эмулировать строгую типизацию в вызовах функций
  Декортаор для проверки прав


  bind:
	позволяет привязать контекст к функции:
		function f() {
			console.log(this);
		}
		var g = f.bind("Context");
		f() //выведется 'Context'

	синтаксис:
		var wrapper = func.bind(context[, arg1, arg2...])
		//arg1, arg2... будут добавлены _перед_ явно переданными аргументами

	если мы просто создаем функцию, в которой какие-то из аргументов будут дефолтными
	 - то это называется карринг (или каррирование)
	пример:
		function mul(a,b); //перемножает два аргумента
		var double = mul.bind(null, 2); //умножает один аргумент на 2

  apply:
  	Форвардинг вызова (если мы вызываем функцию через к-л декоратор
  	то чтобы изнутри все выглядело будто нет никакого декоратора)
  		var result = f.apply(this, arguments);

[[Class]]
	Если написать
		{}.toString.call(date) // [object Date] - здесь Date - это значение секретного свойства [[Class]]
	можно выдрать это свойство через {}.toString.call(obj).slice(8, -1).
	Рабьотает только для встроенных типов

Array.isArray(arr) //тут все понятно

instanceof
		user instanceof User // проверка класса, работает не только для встроенных
							 // при проверке на базовый класс у инстанса наследника <<дополнить позднее>>

JSON
	прокатывают только двойные кавычки
	JSON.parse(str, reviver) - второй аргумент необязательный
	 это функция(key, value) -> value которая может пропарсить значение

	JSON.stringify(value, replacer, space)
	при этом у всех объектов вызывается метод toJSON()
	replacer - массив тех свойств, которые мы хотим добавить
			   либо функция replacer(key, value) -> value
		JSON.stringify(user, function(key, value) {
		  if (key == 'window') return undefined;
		  return value;
		});
		JSON.stringify(user, ["name", "age"])
	space - количество пробелов в отступе (влияет только на красоту)

setTimeout(func / code, delay[, arg1, arg2...]) -> timerId
	аргументы передадутся функции, необязательный параметр
	отменить можно через clearTimeout(timerId)

	аналогично: setInterval/clearInterval //тут учитывается время _между_стартами_функций_
		//кроме IE, который считает время между концом прошлой и стартом следующей
		//чтобы в остальных было как в IE - делаем рекурсивный setTimeout

	во время показа алертов в браузере этот таймер может заморозиться
	 (opera/chrome/safari) а может и нет (IE firefox)

	Все эти дела опасны в плане утечек памяти
	 пока активен таймер - то не чистится функция и ее замыкание

	setInterval(.., 0) //в IE не сработает, в остальных сработает с минимальной задержкой (обычно это 4мс в новых и 15мс в старых)

	если вкладка неактивна - таймер будет срабатывать реже (зависит от браузера)

	можно использовать setTimeout на долгих задачах чтобы иногда возвращать управление браузеру и чтобы он не подвисал

	можно еще через new Function("arg1, arg2...","code")

try catch
	как в плюсах:
		try {}
		catch(err) {}
		finally {}
		//у err есть свойства name, message, stack (есть еще, зависит от браузера)
	из асинхронно запущенных методов ничего не поймает
	finally выполняется всегда: если в try/catch есть return, то finally выполнится перед ретурном

	если что, выкидываем throw err; //err = объект как надо, но в принципе может быть и
									//просто число или строка
	В JavaScript встроен ряд конструкторов для стандартных ошибок:
	SyntaxError, ReferenceError, RangeError и некоторые другие.
	"Проброс ошибки":
	 если мы в cfnch-блоке не знаем как обработать ошибку - то можем выкинуть ее дальше через throw
	 тогда она либо обработается во внешнем обработчике, либо повалит скрипт
	"Оборачивание исключения":
	 Мы пробрасываем ошибку, обрабатываемую во внешнем коде, но в нее запихиваем исходную ошибку
	 чтобы внешний код имел о ней представление

window.onerror:
	функция в браузерах, которая вызывается при необрабатываемой ошибке
	window.onerror = function(message, url, lineNumber);

Наследование (функциональный паттерн):
		function Machine(power) {}
		function CoffeeMachine(power) {
	  		Machine.apply(this, arguments);
	  	}
	Если делать таким макаром, то приватные поля Machine будут
	не видны в CoffeeMachine.
	Условились протектед-члены делать как публичные, но имя начинается с _

	Переопределение методов:
		var parentMethod = this.method;
		this.method = function() {
		    parentMethod.call(this); //здесь если method родителя не забинден на this -
		    						 //то все сломается к пизде. Для этого юзаем call
		    //свой код
		}
	Соответственно, если родительский метод вообще не нужен - то просто переопределяем

Наследование (прототипный паттерн):
	__proto__ : (когда объявляем объекты без new)
		var animal = {};
		var rabbit = {};
		rabbit.__proto__ = animal;
	при переборе полей через for in будут перебираться все -
	 и собственные, и прототипные. Проверка на собственность - hasOwnProperty()

	помимо простого обращения obj.__proto__ есть методы
	 Object.getPrototypeOf(obj) и Object.setPrototypeOf(obj, proto),
	 Object.create(proto, descriptors) - второе - девкрипторы свойств.

	Множественного наследования таким образом нет, реализовывать через цепочку наследования

	prototype : (когда объекты объявляются через new)
		var animal = {};
		function Rabbit(name) {}
		Rabbit.prototype = animal;
		var rabbit = new Rabbit();

	у любого prototype есть конструктор, этим можно пользоваться:
		var rabbit = new Rabbit();
		var rabbit2 = new rabbit.constructor();
	этот конструктор легко потерять:
		Rabbit.prototype = { jumps: true } //всё, конструктора больше нет

	А вообще классы объявляем как в видосе с udacity:
		Rabbit.prototype = Object.create(Animal.prototype);
		//это пишем ДО объявления остальных методов в прототипе, а то они затрутся
		Rabbit.prototype.constructor = Rabbit;
		//это если мы собираемся потом использовать конструктор из прототипа

	Вызов родительского конструктора из дочернего:
		function Rabbit(name) {
		  Animal.apply(this, arguments);
		}

	Вызов родительских методов из дочерних примерно так же:
		Rabbit.prototype.run = function() {
		   Animal.prototype.run.apply(this, arguments);
		   this.jump();
		 }

	instanceof:
		rabbit instanceof Rabbit //вернет true
		rabbit instanceof Animal //вернет true

ES6:
	let - область видимости - блок {}, в цикле для каждой итерации создается своя новая переменная
	const - как let, только упадет если слева от оператора присваивания

	можно почти как в питоне:
		let [firstName, lastName] = ["Илья", "Кантор"];
		firstName; //"Илья"
	Остаток массива выдергиваем так:
		let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");
		rest; // ["Император", "Рима"]
	Можно ставить дефолтные значения:
		let [firstName="Гость", lastName="Анонимный"] = [];
	С объектами тоже прокатит:
		let options = {
		  title: "Меню",
		  width: 100,
		  height: 200
		};
		let {title, width, height} = options;
		title; //"Меню"
		let {width: w, height: h, title} = options;
		w; //100
		let {width: w, height: h, title, somevar = 100500} = options;
		somevar; //100500
	Нюанс:
		let a, b;
		{a, b} = {a:5, b:6};//Выражение внутри {} будет воспринято как блок кода
	  надо так:
	  	({a, b} = {a:5, b:6});
	Можно вкладывать конструкции друг в друга:
		let options = {
		  size: {
		    width: 100,
		    height: 200
		  },
		  items: ["Пончик", "Пирожное"]
		}
		let { title="Меню", size: {width, height}, items: [item1, item2] } = options;
		alert(`${title} ${width} ${height} ${item1} ${item2}`);// Меню 100 200 Пончик Пирожное
	Можно такое же делать в параметрах функций
		function showMenu({title, width, height}) {};

	В функции можно объявлять параметры по умолчанию. Тогда все, что undefined будет заменяться дефолтным значением

	Можно объявить вот так:
		function showName(firstName, lastName, ...rest)
	  это избавит от arguments

	... можно использовать и при вызове функции:
		let numbers = [2, 3, 15];
		Math.max(...numbers); //все равно что Math.max.apply(Math, numbers);

	У функций появилось поле name
		function func() {};
		func.name; //"func"
	  или даже
	  	let func = function() {}; //тоже будет name = "func"

	У функций, объявленных черех function declaration видимость теперь блочная

	=> :
		let inc = x => x+1; //все равно что let inc = function(x) {return x+1;};
		let sum = (a,b) => a + b;
		let getTime = () => "";
		let getTime = () => {f1(); f2(); return ""};
	  в таких функциях нет своего this (он берется из вызвавшего кода)
	  еще нет своего arguments

	Строки:
		` (обратная кавычка) - можно многострочные строки, вставлять выражения через ${varname}


============= YDKJS =================
