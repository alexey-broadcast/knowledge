# Введение. Основные понятия.
## Применение
> `FX` - т.е. "вызвать функцию _F_ с параметром _X_".  

_X_ тоже может быть функцией, даже самой _F_: `FF`

## Абстракция
> `λx.M` - означает `x ↦ M(x)`.  

**ПРИМЕР 1:** `λx.2*x` - функция, кот. возвращает удвоенный аргумент.  
**ПРИМЕР 2:** `λx.2` - константная функция, кот. всегда возвращает 2.  

## Множество λ-термов
Множество λ-термов **Λ** строится из:
 1. Переменных `{x, y, z...} ∈ V`
 2. Применения
 3. Абстракции

```
x ∈ V => x ∈ Λ
M,N ∈ Λ => MN ∈ Λ
M ∈ Λ, x ∈ V => λx.M ∈ Λ
```

**ПРИМЕРЫ λ-ТЕРМОВ:**  

| Со скобками  | То же самое без скобок |
| :-------------: | :-------------: |
| x  | x  |
| (xz)  | xz  |
| (λx.(xz)) | λx.xz |
| (λx.(xz))y | (λx.xz)y |
| λy.(λx.(xz))y | λy.(λx.xz)y |

## Правила опускания скобок
`FXYZ` = `((FX)Y)Z` - 'ассоциативно влево'  
`λxyz.M` = `λx.(λy.(λz.M))` - 'ассоциативно вправо'  
`λx.MNK` = `λx.(MNK)` - вправо насколько возможно  

## α-преобразование (переименование)
> Переименование аргумента, чтобы не наебаться когда подставляем какие-то значения.
Так можно делать только со связанными переменными!  
`λx.M =α λy.M, y ∉ FV(M)`

**ПРИМЕР**: `λy.xy[x:=y] = λy'.xy'[x:=y] = λy'.yy'`  

## β-преобразование (подстановка)
> Подстановка аргумента в функцию называется **β-эквиваленость**.  
`(λx.M)N =β M[x:=N]`, т.е. в терме _M_ мы каждое вхождение _x_ заменяем на _N_.  

**ПРИМЕР:** `(λx.2x+8)17 =β 2*17+8 = 42`

## η-преобразование
> `λx.Mx = M, x ∈ FV(M)`

## Редекс
> Конструкция вида `(λx.M)N` называется **РЕДЕКС** (т.е. мы можем сразу β-подставить)  

## Определение равенства функций
> **Экстенсионально эквивалентные** - те функции, кот. при одинаковом входе дадут одинаковый результат.  

```
∀x : Fx = Gx

Ниже - определение равенства функций
y ∉ FV(F) ∪ FV(G)
Fy = Gy
λy.Fy = λy.Gy
F = G
```

## Свободные и связанные переменные
> `λx.M[x]` - наличие _x_ в теле функции (_x_ при этом аргумент) **связывает** до этого **свободную** _x_.  

**ПРИМЕР 1:** `(λy.(λx.xz)y)w`: _x_, _y_ - связанные, _z_, _w_ - свободные.  
**ПРИМЕР 2:** `(λx.(λx.xz)x)x`: нам только кажется, что здесь полно одинаковых _x_.  
На самом деле это выглядит так: `(λx1.(λx2.x2z)x1)x3`, _x1_, _x2_, _x3_ - **разные _x_**!  
_x1_ и _x2_ - связанные, _x3_ и _z_ - свободные.  

**Связанная переменная полностью описана внутри функции** и про внешний мир ей ничего знать не надо.  
**Свободная переменная глобальна относительно данной функции.**  

> Формально:  
>
Свободные **FV(T)**:
 * FV(x) = {x}
 * FV(MN) = FV(M) ∪ FV(N)
 * FV(λx.M) = FV(M) \ {x}  
>
Связанные **BV(T)**:
 * BV(x) = ∅
 * BV(MN) = BV(M) ∪ BV(N)
 * BV(λx.M) = BV(M) ∪ {x}

## Комбинаторы
> **Комбинатор** - замкнутый (без свободных переменных) терм.  

Некоторые классические комбинаторы:  
 * `1` = `λxy.xy`
 * `I` = `λx.x`
 * `ω` = `λx.xx`
 * `Ω` = `ωω` = `(λx.xx)(λx.xx)`
 * `K` = `λxy.x`
 * `K*` = `λxy.y`
 * `B` = `λfgx.f(gx)`
 * `S` = `λfgx.fx(gx)`

## Каррирование
> **Каррирование** - переход от функции нескольких переменных к последовательным функциям одной переменной.  

Как это делается (в этом примере _Φx_ - это один терм, _x_ - как бы подстрочный):  
Есть `φ(x,y)`, тогда `Φx = λy.φ(x,y)`. `Φ = λx.Φx = λxy.φ(x,y)`  
`ΦXY = (ΦX)Y = ΦxY = (λy.φ(X,y))Y = φ(X,Y)`.

# Аксиомы
 1. `M = M`
 2. `M = N => N = M`
 3. `M = N, N = L => M = L`
 4. `M = M' => MZ = M'Z`
 5. `M = M' => ZM = ZM'`
 6. `M = M' => λx.M = λx.M'`

# Рекурсия

## Теорема о неподвижной точке
`∀F∈Λ ∃X∈Λ | λ ↦ FX=X`  
Док-во:  
Обозначим `W = λx.F(xx)`, `X = WW`  
Тогда `X = WW = (λx.F(xx))W = F(WW) = FX`  
`W` и есть искомая точка.  

## Теорема об Y-комбинаторе
**F(YF) = YF**  
(работает и в обратную сторону)  

∃ комбинатор Y неподвижной точки такой, что `∀F F(YF) = YF`  
`YF = (λx.F(xx))(λx.F(xx))`

Y-комбинатор позволяет ввести рекурсию.  
**ПРИМЕР:** Факториал:  
`fac = λn.iif(iszro n)1(mult n (fac(pred n)))` =>  
`fac = (λfn.iif(iszro n)1(mult n (f(pred n)))) fac` все выражение в скобках обозначим `fac'`
`fac = Y fac'`

Посчитаем для примера факториал трех:
```
fac 3 = (Y fac')3 = fac'(Y fac')3 = 
iif(iszro 3)1(mult 3 (Y fac'(pred 3))) =
mult 3 ((Y fac') (pred 3)) = 
mult 3 (fac' (Y fac') 2) = 
mult 3 (mult 2 (fac' (Y fac') 1)) = 
mult 3 (mult 2 (mult 1 (fac' (Y fac') 0))) = 
mult 3 (mult 2 (mult 1 1))) = 6
```

## Редукция термов
```
KI ≡ (λxy.x)(λz.z) = λyz.z
IIK* ≡ (λx.x)IK* = IK* = (λx.x)(λyz.z) = λyz.z
```
Видно, что процесс носит односторонний характер, термы "упрощаются". Для этого вводят понятие **редукции**:  
Несколько видов стрелочек:
 * `KI →β K*` - редуцируется за один шаг,  
 * `IIK* ↠β K*` - редуцируется за [0, n] шагов,  
 * `KI =β IIK*` - конвертируемо (равно)  

> Терм вида `(λx.M)N` наз. **β-редексом** (или просто редексом).  

> Терм `M[x:=N]` называется **сокращением** редекса `(λx.M)N`

**ПРИМЕР:**
`I(KI)` содержит два редекса:  
`(λx.x)((λyz.y)(λp.p))`  

### Понятие редукции
> Бинарное отношение _R_ над Λ наз. **совместимым** (с операциями λ-исчисления),
> если для любых M,N,Z ∈ Λ:
> M _R_ N ⇒ (ZM) _R_ (ZN),
>   (MZ) _R_ (NZ),
>   (λx.M) _R_ (λx.N)

> Совместимое отношение эквивалентности наз. отношением **конгруэнтности** над Λ.

> Совместимое, рефлексивное и транзитивное отношение наз. отношением **редукции** над Λ.

**ПРИМЕР:**
Возвращаясь к предыдущему примеру, развернем редексы сначала первый потом второй и наоборот:  
`(λx.x)((λyz.y)(λp.p)) →β (λy.zy)(λp.p) →β λzp.p`  
`(λx.x)((λyz.y)(λp.p)) →β (λx.x)(λzp.p) →β λzp.p`  

> **определение**: Бинарное отношение β-редукции ↠β над λ (индуктивно):  
>   (a) M ↠β M  
>   (b) M →β N ⇒ M ↠β N  
>   (c) M ↠β N, N ↠β L ⇒ M ↠β L  

### Отношение конвертируемости =β
> **определение**: Бинарное отношение =β над Λ (индуктивно):  
>   (a) M ↠β N ⇒ M =b N  
>   (b) M =β N ⇒ N =b M  
>   (c) M =β N, N =β L ⇒ M =β L  

Отношение `=β` является отношением конгруэнтности.  
Работает во все стороны (правило (с)): `KI →β K* ←β IK* ←β IIK*` => `KI =b IIK*`

### Нормальная форма
Официально - β-нормальная форма.  
> λ-терм М **находится** в β-нормальной форме (β-NF), если в нем нет подтермов, являющихся β-редексами.

> λ-терм М **имеет** β-нормальную форму, если для некоторого N выполняется M =β N и N находится в β-NF

**Не все термы имеют β-норм форму**.
**ПРИМЕР:** - `Ω = ωω = (λx.xx)(λx.xx) ↠β (λx.xx)(λx.xx) ...`  
Но это еще не доказательство! Может быть, есть такой N, что Ω <<- M ->> N  

Не все последовательности редукций приводят к нормальной форме!  
Пример - `K I Ω` - если наччать с раскрытия Ω, то получится бесконечная редукция.  

Редукцию можно изображать с помощью _редукционного графа_, может быть бесконечен.  
Не все бесконечные не имеют НФ. Если у терма есть НФ - то мы всегда можем к ней перейти.  

## Теорема Чёрча-Россера
*Конфлюэнтность* - если из `M` мы можем перейти к `N` или `K`,
то из них обоих мы можем перейти в какой-ниб `L` (иллюстрация - ромб).  

### Следствия
 1. Если `M =β N`, то у них существует **общий редукт** `L`.  
 2. Если `M` имеет `N` в качестве _β-NF_, то `M` редуцируется к `N` (можем доказать отсутствие NF)  
 3. любой λ-терм имеет не более одной НФ (можем доказать неравенство на основании неравенства НФ термов).  

## Стратегии редукции
 1. Переменная `v` - редукция завершена
 2. Абстракция `λx.M` - редуцируем `M`
 3. Аппликация `MN`:
 4. Разбираем влево: `A B → A1 A2 B → A11 A12 A2 B ...` пока слева не будет переменная или λ.
 5. Если слева стоит λ, то:
 6. Нормальная стратегия: сокращаем редекс `(λx.M)N`
 7. Аппликативная стратегия: сначала сокращаем аргументы функции, потом - саму функцию.

λ-термы представляют в виде **синтаксических деревьев**.

### Головная форма
`λx1 ... xn.y N1 ... Nk, n ≥ 0, k ≥ 0` - головная нормальная форма.  
`λx1 ... xn.(λy.Z) N1 ... Nk, n ≥ 0, k > 0` - λy.Z - головной редекс  
Слабая ГНФ - не-редекс на верхнем уровне. В языках программирования на ней чаще всего останавливается вычисление.  

### Нормальная стратегия:
`NF` - норм. форма: `NF ::== λx.NF | NANF`  
`NANF` - не абстракция: `NANF ::== v | NANF NF`  
`NA` - не абстракция: `NA ::== v | PQ`  
 1. Если `NA → NA'`, то `NA M → NA' M`
 2. Если `M → M'`, то `NA N → NA M'`
 3. Если `M → M'`, то `λx.M → λx.M'`
 4. `(λx.M)N` → `M[x:=N]`

Нормальная стратегия всегда сокращает самый левый внешний редекс.  
**Нормальная стратегия гарантированно приведет к НФ**.  
Ее недостаток - иногда неэффективна: `(λx.Fx(Gx))N → FN(GN)`. `N` придется вычислять дважды (а вдруг он большой и тяжелый).  
А иногда - наоборот, может пропустить тяжелое вычисление: `(λxy.y)N → λy.y`  
Аппликативная стратегия в обоих примерах вычислит `N` один раз.  
Т.е. если какие-то вычисления нужны много раз - нормальная стратегия проигрывает.  

### Аппликативная стратегия:
Как нормальная, но:  
_4. `(λx.M)NF` → `M[x:=NF]`  
_5. Если `N → N'`, то `(λx.M)N → (λx.M)N'`  
Аппликативная стратегия всегда сокращает самый левый внутренний редекс.

# Булевы значения
```
tru = λtf.t //истина
fls = λtf.f //ложь
iif = λbxy.bxy //если

not = λb.b fls tru //не
and = λxy.xy fls //конъюнкция
```

# Типизированное λ-исчисление

 * Выражения - λ-термы
 * Вычисление - их редукция
 * Значение вычисления - нормальная форма (WH)NF

Типы - **синтаксические** конструкции `M:σ`. В данном случае не надо их рассматривать как
некоторые множества!

 1. Типы дают частичную спецификацию: `f:N→N`.
 2. Правильно типизированные программы не могут "сломаться" (редукция выражения по идее не изменит
    его входного-выходного типа).
 3. Типизированные программы всегда завершаются (на самом деле это не всегда так :).
 4. Проверка типов отлавливает простые ошибки.

## Классификации систем типов
 1. Статические (типы проверяются во время компиляции) vs динамические (типы проверяются в рантайм)
 2. Явные (где мы должны явно писать типы) vs неявные (где тип выводится из структуры выражения)
 3. Сильные (каждое выражение типизировано однозначно и точно) vs слабые (допускает приведение типов в выражении)

В императивном языке типы возникают из интерпретации различных состояний.  
В функциональных языках типы возникают из анализа арностей функций.  

**ПРИМЕР:** Функции `Ш = λx.x` может быть приписан тип `α→α` "принимает выражение какого-то типа
и возвращает выражение того же самого типа".  
В общем случае тип `α→β` - принимает значение типа `α` и возвращает значение типа `β`.

## Два семейства систем типов
 1. В стиле Карри - неявная
 2. В стиле Чёрча - явная

## Два взгляда на системы типов
 1. Программистский подход: термы - программы, типы - их частичные спецификации
 2. Логический подход: типы - высказывания, термы - их доказательства

Связь между ними наз. _соответствием Карри-Говарда_.  

## **Просто типизированное λ-исчисление**
> Множество типов определяется индуктивно (`T` - множество типов):  
> `α, β... ∈ T` (переменные типа)  
> `σ, τ ∈ T ⇒ (σ→τ) ∈ T` (типы пространства функций)  

Соглашение: `α, β, γ` - используем для типовых переменных (каких-то конкретных типов),
`σ, τ, ρ` - для произвольных типов (как большие латинские буквы в λ-термах).  

Скобки опускаем правоассоциативно:  

| Со скобками  | То же самое без скобок |
| :-------------: | :-------------: |
| (α→β) | α→β |
| (α→(β→γ)) | α→β→γ |
| ((α→β)→γ) | (α→β)→γ |
| ((α→β)→((α →γ)→(α→γ))) | (α→β)→(α →γ)→α→γ |

На правом конце всегда должна выйти переменная.  

### Как типизировать термы?
 1. Если терм - переменная, то как угодно: `x:α`
 2. Если терм - аппликация `MN`, то:
   * `M` должно быть функцией, т.е. иметь стрелочный тип `M:σ→τ`
   * `N` должно быть подходящим аргументом, т.е. `N:σ`
   * Вся аппликация должна иметь тип результата применения, т.е. `(MN):τ`
 3. Если терм - абстракция `λx.M`, то его тип - стрелочный: `λx.M:σ→τ`

**ПРИМЕР:** Для `x:α` имеем `(λx.x):α→α`  
В стиле Чёрча: `(λx:α.x): α→α`. Типы, после двоеточия, еще пишут сверху, как степень  
**В общем**, если имеем `λxy.M`, то тип этого выражения будет `тип_x→тип_y→тип_M`

### Как согласуются скобки в термах и типах
В данном примере _все_ скобки можно опустить (кроме самых внешних у аппликаций).  
Пусть `M:α, N:β, P:γ`  
Тогда:
```
F:α→(β→(γ→δ))
(FM):β→(γ→δ)
((FM)N):γ→δ
(((FM)N)P):δ
```

## Формально:
**Субъект** типизации - слева от двоеточия  
**Предикат** типизации - справа от двоеточия  
**Объявление** - утверждение о типизации с термовой переменной в качестве субъекта  
**Контекст** - множество объявлений с _различными_ переменными в качестве субъекта 
(т.е. он нужен для описания типов свободных переменных) `Γ=x:α,b:β`.  

_Далее: '|-' - это один слитный символ, слева от него - контекст, справа - терм_  
Утверждение `M:τ` называется **_выводимым_** в контексте Γ, обозначение `Γ |- M:τ`  
Его вывод может быть произведен по правилам (Карри):  
```
(x:σ) ∈ Γ ⇒ Γ |- x:σ
Γ |- M:σ→τ, Γ |- N:σ ⇒ Γ |- (MN):τ
Γ, x:σ |- M:τ ⇒ Γ |- (λx.M):σ→τ
```

У Чёрча тяжело записывать.  

**Некоторые конструкции не типизируются.**  
Например, самоприменение `xx` и термы, которые его содержат.  

Есть понятие **подстановки типов**.  
Подстановка типов не мешает редукции, подстановка термов не должна типов.  
Тип терма сохраняется при β-редукциях.  

Для рассмотренной системы разрешимы задачи:
 * Проверки типа
 * Синтеза типа (какого типа данная переменная?)
 * Обитаемости типа

### Нормализуемость терма
 1. Терм **слабо нормализуем** (WN), если _существует_ последовательность редукций, приводящая его к НФ
 2. Терм **сильно нормализуем** (SN), если _любоая_ последовательность редукций приводит его к НФ

Система типов
 1. **Слабо нормализуема**, если все ее допустимые термы WN
 2. **Сильно нормализуема**, если все ее допустимые термы SN

Системы Карри и Чёрча сильно нормализуемы, любой допустимый терм в них всегда редуцируется к НФ.  



# Haskell

## Общие моменты
> Знак равенства `=` задает _связывание_ (не присваивание)

```haskell
x = 52 -- глобальное
foo = let z = x + y -- глобальное (foo), локальное (z)
      in print z    -- отступ (layout rule)
```

Первый символ идентификатора д.б. в нижнем регистре, с заглавной буквы начинаются типы.  
В GHCi `let` - для глобального связывания
В файлах исходников все, что с нулевым отступом - глобально для файла.  

**Layout rule** (правило отступа) - если мы начали какое-то выражение, то на след. строке мы должны
продолжить его с тем же отступом, с каким и начали.  

Равенство может задавать функцию:
```haskell
add x y = x + y -- определение
fortyTwo = add 40 2 -- вызов
```
Допустимо использовать лямбда-выражения. В след. примере все три определения эквивалентны:
Но: первый пример "более полиморфичен" // TODO: дописать
```haskell
add x y = x + y
add' x = \y -> x + y
add'' = \xy -> x + y
```

Соглашения об ассоциативности - такие же, как в λ-исчислении:
```haskell
bad = print add 1 2 -- ошибка арности
good = print (add 1 2) -- все ок
```

Порядок определений не важен:
```haskell
print (add 1 2) -- add определен ниже, но это похуй
add x y = x + y
```

Иммутабельность
```haskell
z = 1 -- ок, определили z
z = 2 -- ошибка, переопределять нельзя
```

На разных уровнях вложенности может использоваться одно и то же имя:
```haskell
q q = \q -> q -- ок: это комбинатор К*, только запутанный:
-- первое q - идентификатор, второй - первый параметр, q после лямбды - второй параметр
```

Ленивость
```haskell
k = \x y -> x
k 42 undefined -- 42
```
`undefined` - стандартная функция, цель которой - всегда расходиться.
Она всегда вылетает с ошибкой, по типу подходит в любое место.

## Пример: факториал
```haskell
fac n = if n > 1
        then n * fac (n - 1)
        else 1
```
Пример выше - не очень хорош, перепишем в _хвостовую рекурсию_ с помощью аккумулирующего параметра:
```haskell
fac' n = helper 1 n
helper acc n = if n > 1
               then helper (acc * n) (n - 1)
               else acc
```
Но: компилятор хаскеля умный, оба примера он оптимизирует в цикл.


### Where, let .. in
Прошлый пример засирает глобальное пространство имен функцией `helper`.  
Чтобы избежать этого, используем `where` и `let ... in`:
```haskell
-- пример where
fac n' = helper 1 n'
  where helper acc n = if n > 1
                       then helper (acc * n) (n - 1)
                       else acc
```

```haskell
-- пример let ... in
fac n' =
  let helper acc n = if n > 1
                     then helper (acc * n) (n - 1)
                     else acc
  in helper 1 n'
```
Перед `where`, `let`, `in` не обязательно делать такой же отступ (принято - два пробела)  
`where` немного хуже, чем `let .. in`, т.к. второй - полноценное выражение которое имеет тип, первое - сахарок.  

### Предохранители (guards)
```haskell
-- просматриваются сверху вниз до первого истинного
fac n' = helper 1 n'
  where helper acc n | n > 1     = helper (acc * n) (n - 1)
                     | otherwise = acc

fac' n' =
  let helper acc n | n > 1     = helper (acc * n) (n - 1)
                   | otherwise = acc
  in helper 1 n’
```

`where` может быть общей для предохранителей:
```haskell
f x y | y > z ...
      | y == z ...
      | y < z ...
  where z = x * x
```

## Типы в Haskell

### Встроенные типы
 * `Bool` — булево значение (`True`, `False`);
 * `Char` — символ Юникода;
 * `Int` — целое фиксированного размера;
 * `Integer` — целое произвольного размера;
 * `type1 -> type2` — тип функции;
 * `(type1, type2, ..., typeN)` — тип кортежа;
 * `()` — единичный тип, с одной константой ();
 * `[type1]` — тип списка с элементами типа type1.

В GHCi для определения типа используют команду `:type` (или  `:t`): `:t <выражение>`

Можно явно указывать тип выражения: `42::Integer`
```haskell
-- 'конструкторы'
x::Integer
-- x - 'конструктор данных'
-- Integer - 'конструктор типа'
```

**ПРИМЕР**: булев тип представляет собой перечисление:
```haskell
-- валидный синтаксис хаскеля
data Bool = True | False
-- True и False - 'конструкторы данных'. Их имена должны начинаться с заглавной буквы!
-- Bool - 'конструктор типа'
```
Еще один способ задавать функции, эта конструкция наз. 'сопоставление с образцом':
```haskell
-- в принципе, определение типа необязательно, а если есть - то м.б. расположено где угодно
-- но принято так
not       :: Bool -> Bool
-- порядок важен!
not True  =  False
not False =  True
```

**ПРИМЕР** функции двух аргументов:
```haskell
mult :: Integer -> (Integer -> Integer)
mult x1 x2 = x1 * x2
```
Тут можно делать частичное применение: `:type mult 2` => `mult 2 :: Integer -> Integer`
```haskell
foo = mult 2
foo 3 -- 6
```

### Полиморфизм

#### Параметрический полиморфизм
```haskell
k = \x y -> x
```
Если мы после этого спросим `:type k`, то вернется `k :: t -> t1 -> t` - _t_ - просто какие-то переменные типа.  
Функцию _k_ можем применять к любым типам.  

#### Ограниченная квантификация
```haskell
add x y = x + y

-- GHCi:
:type add
add :: Num a => a -> a -> a
```
`=>` означает контекст, `Num a` означает, что _add_ мы можем вызывать только для тех типов _a_,
кот. относятся к _классу типов Num_. Т.е. `Num` - это **класс типов** (если найти аналогию c
Java/C++ - то тип _a_ должен реализовывать интерфейс _Num_).  

## Система модулей
Модуль - это файл:
```haskell
module A (foo, bar) where -- foo и bar из этого модуля экспортируются
import B (f, g, h) -- импортируем f, g и h из B.
foo = f g
bar = ...
baz = ...
-- если скобок в экспорте/импорте нет - то импортируются/экспортируются все имена
```
Программа состоит из набора модулей.  
Модули позволяют управлять пространствами имен.  
Инкапсуляция через списки импорта и экспорта.  

Конфликты имен разрешаются через полные имена:
```haskell
import qualified B (f, g, h)
foo = B.f B.g
```

В GHCi след. команды: `:load` - загружает модуль, `:module` управляет областью видимости (подгрузить модуль).  

## Операторы и сечения
**Оператор** - комбинация одного и более символов `! # $ % & * + . / < = > ? @ \ ^ | - ~`.  
Они все определены в `Prelude`.  
Все операторы инфиксные и бинарные (за искл. унарного префиксного `-`, кот. вызывает `Prelude.negate`)  
Еще есть `:` - играет некую специальную роль.  

Можно определять свои операторы:
```haskell
a *+* b = a * a + b * b -- определили оператор суммы квадратов
3 *+* 4 -- 25, вызвали этот оператор

-- то же самое в функциональном стиле:
(*+*) a b = a * a + b * b
-- использовать (как и определить) можно и префиксно, и инфиксно:
3 *+* 4 -- 25
(*+*) 3 4 -- 25
```

Функции мы тоже можем объявить или использовать в операторном стиле (заключив в обратные кавычки):
```haskell
-- эти два эквивалентны
plus a b = a + b
a `plus` b = a + b
-- эти тоже
plus 3 4 -- 7
3 `plus` 4 -- 7
```
Т.е. _любое имя функции, заключенное в обратные кавычки, превращается в оператор_.  

**Проблема ассоциативности и приоритетов**
```haskell
2 *+* 3 + 4 -- ?
2 *+* 3 *+* 4 -- ?
```
Для этого в хаскеле есть объявления `infix`, `infixl`, `infixr`:
```haskell
infixl 6 *+*, `plus` - левоассоциативны, имеют 6 приоритет
```
Если где-то компилятор не сможет однозначно разобраться - то ругнется и не скомпилит.  

### Приоритет стандартных операторов
```haskell
-- 10 приоритет имеет применение функции
infixl 9 !! -- взятие элемента из списка: someList !! 7 - как в др. языках someList[7]
infixr 9 . -- оператор композиции
infixr 8 ^, ^^, ** -- операторы возведения в степень для разных типов
infixl 7 *, /, ‘quot‘, ‘rem‘, ‘div‘, ‘mod‘
infixl 6 +, -
infixr 5 ++, : -- операторы списков: конкатенация и прицепление в голову списка
infix 4 ==, /=, <, <=, >=, >, ‘elem‘, ‘notElem‘ - elem и notElem - проверка на вхождение в список: 5 `elem` someList
infixr 3 && - конъюнкция
infixr 2 || - дизъюнкция
infixl 1 >>, >>= -- TODO
infixr 1 =<< -- TODO
infixr 0 $, $!, ‘seq‘ -- TODO. $ - аппликация нулевого приоритета
```

### Сечения
Операторы на самом деле просто функции, поэтому допускают частичное применение
```haskell
-- левое сечение (левый аргумент)
(2 *+*) == (*+*) 2 == \y -> 2 *+* y
-- правое сечение (правый аргумент)
(*+* 3) == \x -> x *+* 2
```
Скобки обязательны!  

### Оператор $
Оператор $ - это применение с наинижайшим приоритетом, позволяет избавиться от скобок:
```haskell
f (g x (h y)) == f $ g x $ h y
```

### Бесточечный стиль
```haskell
-- Все три - эквивалентны
foo x = bar baz x
foo = \x -> bar baz x
foo = bar baz
```


## Ленивость и строгость
Рассмотрим тип `Bool`.  
В нем определено два значения: `data Bool = True | False`.  
Но если взять `bot = not bot` - то это приведет к вечному циклу.  
Для таких случаев есть определенное значение `⊥` (_основание_): в хаскелле это значение, разделяемое
всеми типами. Ошибкам (но не исключениям) тоже присваивается это значение.  
Хаскелль _гарантирует_ вызов _по необходимости_:  
```haskell
bot = not bot -- вечный цикл, значение = ⊥
const42 x = 42
const42 bot -- 42, bot просто не вызовется
```
Такие функции (игнорирующие значение своего аргумента) наз. **нестрогими** по этому аргументу.  
Для **строгих** функций, наоборот, всегда выполняется `f ⊥ = ⊥`  

## Форсированные вычисления
### `seq` и `deepseq`
Для них есть комбинатор `seq`, расширяющий язык (частью языка и λ-исчисления он не является):
```haskell
-- всегда возвращает второй аргумент, если первый - не ⊥
seq :: a -> b -> b
seq ⊥ b = ⊥
seq a b = b -- если a !== ⊥
```
C чисто синаксической точки зрения это `λa b.b`, но он "нарушает" ленивую семантику языка,
позволяя форсировать вычисление без необходимости.
```haskell
-- как он работает:
seq undefined 42 -- выкинет ошибку
seq (undefined, undefined) 42 -- не выкинет ошибку, конструктор пары
seq (\x -> undefined) 42 -- не выкинет ошибку, λ-абстракция
```
Таким образом, seq не сильно форсирует вычисления. есть еще `deepseq`

### Оператор `$!`: аппликативный вызов
```haskell
const42 $! undefined -- ошибка выкинется
```


**ПРИМЕР** форсирования вычислений:  
В данном примере мы форсируем вычисление `acc`, чтобы не нагнетался долгий вызов.  
Тут мы не полагаемся на оптимизацию.
```haskell
fac n' = helper 1 n'
  where helper acc n | n > 1     = (helper $! acc * n) (n - 1)
                     | otherwise = acc
```

## Алгебраические типы данных
### Сопоставление с образцом (pattern matching)
Возьмем функцию, которая меняет местами два элемента пары:
```haskell
swap :: (a,b) -> (b,a)
swap (x, y) = (y, x) -- вполне законный код, destructuring работает
```
Выражение `(x, y)` - _образец_. При вызове
```haskell
swap (42, True)
 -- (True, 42)
```
Происходит **сопоставление с образцом**:
 * проверяется, что конструктор `(,)` - подходящий
 * переменные `x` и `y` связываются со значениями `42` и `True`

### Перечисления
Перечисление - тип с 0-арным конструктором данных.
```haskell
data Color = Red | Green | Blue | White | Black
  deriving Show
```
`Color` - конструктор типа  
`Red`, `Green`, `...` - конструктор данных  
`deriving Show` - это значит что мы задаем класс типа. В данном случае `Show` позволяет выводить
элементы данного типа в строку.

Сопоставление с образцом происходит сверху вниз:
```haskell
isRGB :: Color -> Bool
isRGB Red = True
isRGB Green = True
isRGB Blue = True
isRGB _ = False -- wildcard, используем подчеркивание когда нам пофиг что прилетело в аргумент
```

### Типы с конструктором: точка
```haskell
data PointDouble = PtD Double Double   deriving Show

-------interpret >
> type PtD
PtD :: Double -> Double -> PointDouble
-------interpret <

midPointDouble :: PointDouble -> PointDouble -> PointDouble
midPointDouble (PtD x1 y1) (PtD x2 y2) = PtD ((x1 + x2) / 2) ((y1 + y2) / 2)

-- теперь можем вызвать как хотим:
midPointDouble (PtD 0 0) (PtD 10 10) -- PtD 5 5
x = Ptd 2 2
midPointDouble x (PtD 10 10) -- PtD 6 6
```
С точки зрения языка `PtD` - это просто функция, которая ничего не делает, просто возвращает
объект нужного типа.

### Полиморфизм
Перепишем предыдущий пример:
```haskell
data Point = Pt a a   deriving Show

-------interpret >
> type Pt
Pt :: a -> a -> Point a
-------interpret <

midPoint:: Point -> Point -> Point
midPoint (Pt x1 y1) (Pt x2 y2) = Pt ((x1 + x2) / 2) ((y1 + y2) / 2)

-- теперь можем вызвать как хотим:
midPoint (Pt 0 0) (Pt 10 10) -- Pt 5 5
x = Ptd 2 2
midPoint x (Pt 10 10) -- Pt 6 6
```
Здесь `Point` - это оператор над типами, ожидает некоторого типа и возвращает некоторый тип.  

В хаскеле если у переменной есть тип `type`, то у типа класс `kind`:
```haskell
-------interpret >
> kind Point
Point :: * -> *
> kind Point Int
Point Int :: *
```
Все простые типы имеют `kind = *`.  
Мы не можем задать переменную, тип которой имеет стрелочный kind.

#### Избыточный полиморфизм и умолчания
Прошлый пример вполне может сломаться, т.к. у нас м.б. не определены `+` и `/` для каких-то типов.  
Поэтому ограничиваем контекстом:
```haskell
midPoint :: Fractional a => Point a -> Point a -> Point a
```

Для типов по умолчанию есть ключевое слово `default`, ему даем _последоватльность_ типов:
```haskell
default (Integer, Double) -- это дефолт - дефолтный
```

#### Рекурсивные типы
**ПРИМЕР**: Тип списка
```haskell
data List a = Nil | Cons a (List a)   deriving Show

-- типы конструкторов:
Nil :: List a
Cons :: a -> List a -> List a

-- объявим новую переменную этого типа
let l = Cons 'a' (Cons 'b' (Cons 'c' Nil)) -- :: List Char
```
> В хаскелле список должен содержать значения только одного типа

Обработка списка - через рекурсию и сопоставление с образцом
```haskell
len               :: List a -> Int -- длина списка
len Nil           =  0
len (Cons _ xs) =  1 + len xs
```
> В хаскелле принято голову обозначать `x`, а хвост - `xs`

В примере мы сами накузьмичили список, но у хаскелля есть встроенный:
```haskell
data [] a = [] | a : ([] a)
infixr 5 : -- двоеточие - это конструктор списка: `x : xs`
-- Для удобства введен синтаксический сахар:
-- сахар 1
[] a = [a]
-- сахар 2
[1,2,3] = 1:2:3:[]

-- пример определения функции
head :: [a] -> a
head (x:_) = x
head [] = error "Prelude.head: empty list"

-- определим ту же самую функцию немного иначе:
head' xs = case xs of
  (x:_) -> x
  []    -> error "head': empty list"
```
`case of` - выражение, его можно использовать в любом месте кода.  

Если нас интересует только один образец - мы можем запихнуть его прямо в лямбду:
```haskell
head = \(x:_) -> x
```

#### Как происходит сопоставление с образцом
 * Сверху вниз, слева направо (если несколько образцов в строке)
 * Сопоставление с образцом может быть:
  1. Успешным (succeed)
  2. Неуспешным (fail)
  3. Расходящимся (diverge)

**ПРИМЕР**
```haskell
foo (1, 2) = 3
foo (0, _) = 5
```
Подставляем след. пары:
 * `(0, undefined)` - неудача в первом образце, успех во втором
 * `(undefined, 0)` - расходимость в первом же образце
 * `(2, 1)` - две неудачи => расходимость (из-за того, что образцы кончились)
 * `(1, 5 - 3)` - 5 - 3 вычислится, _сопоставление с образцом форсирует вычисление_
 * `()`

#### As-образец
```haskell
dupFirst        :: [a] -> [a]
dupFirst (x:xs) = x:x:xs
```
Мы можем присвоить псевдоним всей левой части, и использовать его в правой части:
```haskell
dupFirst          :: [a] -> [a]
dupFirst s@(x:xs) = x:s
```

#### Неопровержимые (irrefutable) образцы
 * wild-cards
 * as-образцы
 * формальные параметры-переменные
 * _ленивые образцы_

**Ленивые образцы** задаются с помощью `~`. Сопоставление с ними всегда успешно, связывание
откладывается до момента использования:
```haskell
(***) f g ~(x, y) = (f x, g y)

-- с тильдой следующий вызов не выдаст ошибки:
(const 1 *** const 2) undefined -- в этом вызове undefined подставляется на место (x, y),
-- но const игнорирует свой второй аргумент
```

#### Форсирование строгости
**Строгий конструктор данных**: флаг строгости (`!`) позволяет форсировать вычисление соотв. поля.
```haskell
data Complex a = !a :+ !a

с = (2+3):+(3+2) -- вычисления не будут откладываться, и произойдут сразу
```

#### Bang pattern
Когда вычисления должны форсироваться всегда при вызове
```haskell
:set -XBangPatterns -- включить ключ обязательно
let foo !x = True
foo undefined -- Exception Prelude.undefined
-- а без воскл.знака вернулось бы True
```

### `type`
`type` задает синоним типа:
```haskell
type String = [Char]
```
Для удобства введен синтаксический сахар:
```haskell
"Hello" == ['H', 'e', 'l', 'l', 'o']
```

### `newtype`
`newtype` задает новый тип, который с помощью конструктора упаковывает старый тип:
```haskell
type Age1 = Int
newtype Age2 = Age Int -- Age - это конструктор типа Age
```

## Метки полей
Для доступа к полям типа-произведения `data Point a = Pt a a` приходится использовать спец.
селекторы `\(Pt x _) -> x` и `\(Pt _ y) -> y`.  
Но можно при определении типа определить метки полей: `data Point' a = Pt' {ptx, pty :: a}   deriving Show`
Метки имеют тип `Point' a -> a` и работают как селекторы.  
```haskell
data Point' a = Pt' {ptx, pty :: a}   deriving Show

let myPt = Pt' 3 2
ptx myPt -- 3

let myPt2 = Pt' {ptx = 3} -- тип будет Point' Integer
-- в GHCi высрет варнинг
ptx myPt2 -- 3
pty myPt2 -- ошибка

-- можно использовать метки полей как селекторы
absP p = sqrt (ptx p ^ 2 + pty p ^ 2)

-- можно связать их с переменными в образце
absP' (Pt' {ptx = x, pty = y}) = sqrt (x ^ 2 + y ^ 2)

-- с помощью меток структуры можно "обновлять"
let myPt4 = Pt' {ptx = 7, pty = 8} -- Pt' 7 8
myPt4 {ptx = 42} -- Pt' 42 8
```

## Стандартные алгебраические типы 1:47:40

