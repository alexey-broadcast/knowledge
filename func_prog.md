# Введение. Основные понятия.
## Применение
> `FX` - т.е. "вызвать функцию _F_ с параметром _X_".  

_X_ тоже может быть функцией, даже самой _F_: `FF`

## Абстракция
> `λx.M` - означает `x ↦ M(x)`.  

**ПРИМЕР 1:** `λx.2*x` - функция, кот. возвращает удвоенный аргумент.  
**ПРИМЕР 2:** `λx.2` - константная функция, кот. всегда возвращает 2.  

## Множество λ-термов
Множество λ-термов **Λ** строится из:
1. Переменных `{x, y, z...} ∈ V`
2. Применения
3. Абстракции

```
x ∈ V => x ∈ Λ
M,N ∈ Λ => MN ∈ Λ
M ∈ Λ, x ∈ V => λx.M ∈ Λ
```

**ПРИМЕРЫ λ-ТЕРМОВ:**  

| Со скобками  | То же самое без скобок |
| :-------------: | :-------------: |
| x  | x  |
| (xz)  | xz  |
| (λx.(xz)) | λx.xz |
| (λx.(xz))y | (λx.xz)y |
| λy.(λx.(xz))y | λy.(λx.xz)y |

## Правила опускания скобок
`FXYZ` = `((FX)Y)Z` - 'ассоциативно влево'  
`λxyz.M` = `λx.(λy.(λz.M))` - 'ассоциативно вправо'  
`λx.MNK` = `λx.(MNK)` - вправо насколько возможно  

## α-преобразование (переименование)
> Переименование аргумента, чтобы не наебаться когда подставляем какие-то значения.
Так можно делать только со связанными переменными!  
`λx.M =α λy.M, y ∉ FV(M)`

**ПРИМЕР**: `λy.xy[x:=y] = λy'.xy'[x:=y] = λy'.yy'`  

## β-преобразование (подстановка)
> Подстановка аргумента в функцию называется **β-эквиваленость**.  
`(λx.M)N =β M[x:=N]`, т.е. в терме _M_ мы каждое вхождение _x_ заменяем на _N_.  

**ПРИМЕР:** `(λx.2x+8)17 =β 2*17+8 = 42`

## η-преобразование
> `λx.Mx = M, x ∈ FV(M)`

## Редекс
> Конструкция вида `(λx.M)N` называется **РЕДЕКС** (т.е. мы можем сразу β-подставить)  

## Определение равенства функций
> **Экстенсионально эквивалентные** - те функции, кот. при одинаковом входе дадут одинаковый результат.  

```
∀x : Fx = Gx

Ниже - определение равенства функций
y ∉ FV(F) ∪ FV(G)
Fy = Gy
λy.Fy = λy.Gy
F = G
```

## Свободные и связанные переменные
> `λx.M[x]` - наличие _x_ в теле функции (_x_ при этом аргумент) **связывает** до этого **свободную** _x_.  

**ПРИМЕР 1:** `(λy.(λx.xz)y)w`: _x_, _y_ - связанные, _z_, _w_ - свободные.  
**ПРИМЕР 2:** `(λx.(λx.xz)x)x`: нам только кажется, что здесь полно одинаковых _x_.  
На самом деле это выглядит так: `(λx1.(λx2.x2z)x1)x3`, _x1_, _x2_, _x3_ - **разные _x_**!  
_x1_ и _x2_ - связанные, _x3_ и _z_ - свободные.  

**Связанная переменная полностью описана внутри функции** и про внешний мир ей ничего знать не надо.  
**Свободная переменная глобальна относительно данной функции.**  

> Формально:  
>
Свободные **FV(T)**:
 * FV(x) = {x}
 * FV(MN) = FV(M) ∪ FV(N)
 * FV(λx.M) = FV(M) \ {x}  
>
Связанные **BV(T)**:
 * BV(x) = ∅
 * BV(MN) = BV(M) ∪ BV(N)
 * BV(λx.M) = BV(M) ∪ {x}

## Комбинаторы
> **Комбинатор** - замкнутый (без свободных переменных) терм.  

Некоторые классические комбинаторы:  
 * `1` = `λxy.xy`
 * `I` = `λx.x`
 * `ω` = `λx.xx`
 * `Ω` = `ωω` = `(λx.xx)(λx.xx)`
 * `K` = `λxy.x`
 * `K*` = `λxy.y`
 * `B` = `λfgx.f(gx)`
 * `S` = `λfgx.fx(gx)`

## Каррирование
> **Каррирование** - переход от функции нескольких переменных к последовательным функциям одной переменной.  

Как это делается (в этом примере _Φx_ - это один терм, _x_ - как бы подстрочный):  
Есть `φ(x,y)`, тогда `Φx = λy.φ(x,y)`. `Φ = λx.Φx = λxy.φ(x,y)`  
`ΦXY = (ΦX)Y = ΦxY = (λy.φ(X,y))Y = φ(X,Y)`.

# Аксиомы
1. `M = M`
2. `M = N => N = M`
3. `M = N, N = L => M = L`
4. `M = M' => MZ = M'Z`
5. `M = M' => ZM = ZM'`
6. `M = M' => λx.M = λx.M'`

#Рекурсия

## Теорема о неподвижной точке
`∀F∈Λ ∃X∈Λ | λ ↦ FX=X`
Док-во:  
Обозначим `W = λx.F(xx)`, `X = WW`  
Тогда `X = WW = (λx.F(xx))W = F(WW) = FX`  
`W` и есть искомая точка.  

## Теорема об Y-комбинаторе
∃ комбинатор Y неподвижной точки такой, что `∀F F(YF) = YF`  
`YF = (λx.F(xx))(λx.F(xx))`

Y-комбинатор позволяет ввести рекурсию.  
**ПРИМЕР:** Факториал:  
`fac = λn.iif(iszro n)1(mult n (fac(pred n)))` =>  
`fac = (λfn.iif(iszro n)1(mult n (f(pred n)))) fac` все выражение в скобках обозначим `fac'`
`fac = Y fac'`





# Булевы значения
```
tru = λtf.t //истина
fls = λtf.f //ложь
iif = λbxy.bxy //если

not = λb.b fls tru //не
and = λxy.xy fls //конъюнкция
```
